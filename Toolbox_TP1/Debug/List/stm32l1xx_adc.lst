###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        24/Nov/2014  11:34:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c
#    Command line =  
#        "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c"
#        -D USE_STDPERIPH_DRIVER -D STM32L1XX_XL -lcN "D:\Mes
#        Documents\ST32\Toolbox_TP1\Debug\List\" -o "D:\Mes
#        Documents\ST32\Toolbox_TP1\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\"
#        -I "D:\Mes Documents\ST32\Toolbox_TP1\Libraries\CMSIS\Include\" -I
#        "D:\Mes Documents\ST32\Toolbox_TP1\" -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\stm32l1xx_nucleo\" -Ol
#    List file    =  
#        D:\Mes Documents\ST32\Toolbox_TP1\Debug\List\stm32l1xx_adc.lst
#    Object file  =  
#        D:\Mes Documents\ST32\Toolbox_TP1\Debug\Obj\stm32l1xx_adc.o
#
###############################################################################

D:\Mes Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    31-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           + Initialization and Configuration
     10            *           + Power saving
     11            *           + Analog Watchdog configuration
     12            *           + Temperature Sensor & Vrefint (Voltage Reference internal) management 
     13            *           + Regular Channels Configuration
     14            *           + Regular Channels DMA Configuration
     15            *           + Injected channels Configuration
     16            *           + Interrupts and flags management
     17            *         
     18            *  @verbatim
     19          ================================================================================
     20                                ##### How to use this driver #####
     21          ================================================================================
     22              [..]
     23              (#) Configure the ADC Prescaler, conversion resolution and data alignment 
     24                  using the ADC_Init() function.
     25              (#) Activate the ADC peripheral using ADC_Cmd() function.
     26              
     27              *** Regular channels group configuration ***
     28              ============================================
     29              [..]
     30              (+) To configure the ADC regular channels group features, use 
     31                  ADC_Init() and ADC_RegularChannelConfig() functions.
     32              (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     33                  function.
     34              (+) To configurate and activate the Discontinuous mode, use the 
     35                  ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
     36              (+) To read the ADC converted values, use the ADC_GetConversionValue()
     37                  function.
     38            
     39              *** DMA for Regular channels group features configuration ***
     40              =============================================================
     41              [..]
     42              (+) To enable the DMA mode for regular channels group, use the 
     43                         ADC_DMACmd() function.
     44              (+) To enable the generation of DMA requests continuously at the end
     45                         of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     46                         function.
     47                       
     48              *** Injected channels group configuration ***
     49              =============================================
     50              [..]
     51              (+) To configure the ADC Injected channels group features, use 
     52                  ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     53                  functions.
     54              (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     55                  function.
     56              (+) To activate the Injected Discontinuous mode, use the 
     57                  ADC_InjectedDiscModeCmd() function.
     58              (+) To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     59                  function.
     60              (+) To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     61                  function.
     62          
     63            @endverbatim
     64            *
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     69            *
     70            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     71            * You may not use this file except in compliance with the License.
     72            * You may obtain a copy of the License at:
     73            *
     74            *        http://www.st.com/software_license_agreement_liberty_v2
     75            *
     76            * Unless required by applicable law or agreed to in writing, software 
     77            * distributed under the License is distributed on an "AS IS" BASIS, 
     78            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     79            * See the License for the specific language governing permissions and
     80            * limitations under the License.
     81            *
     82            ******************************************************************************
     83            */
     84            
     85          /* Includes ------------------------------------------------------------------*/
     86          #include "stm32l1xx_adc.h"
     87          #include "stm32l1xx_rcc.h"
     88          
     89          /** @addtogroup STM32L1xx_StdPeriph_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup ADC 
     94            * @brief ADC driver modules
     95            * @{
     96            */
     97          
     98          /* Private typedef -----------------------------------------------------------*/
     99          /* Private define ------------------------------------------------------------*/
    100          /* ADC DISCNUM mask */
    101          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
    102             
    103          /* ADC AWDCH mask */
    104          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0) 
    105            
    106          /* ADC Analog watchdog enable mode mask */
    107          #define CR1_AWDMODE_RESET         ((uint32_t)0xFF3FFDFF)
    108            
    109          /* CR1 register Mask */
    110          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF) 
    111             
    112          /* ADC DELAY mask */            
    113          #define CR2_DELS_RESET            ((uint32_t)0xFFFFFF0F)
    114             
    115          /* ADC JEXTEN mask */
    116          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)
    117            
    118          /* ADC JEXTSEL mask */
    119          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)
    120            
    121          /* CR2 register Mask */
    122          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    123          
    124          /* ADC SQx mask */
    125          #define SQR5_SQ_SET               ((uint32_t)0x0000001F)  
    126          #define SQR4_SQ_SET               ((uint32_t)0x0000001F)  
    127          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    128          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    129          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)
    130          
    131          /* ADC L Mask */
    132          #define SQR1_L_RESET              ((uint32_t)0xFE0FFFFF) 
    133          
    134          /* ADC JSQx mask */
    135          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    136           
    137          /* ADC JL mask */
    138          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    139          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    140          
    141          /* ADC SMPx mask */
    142          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    143          #define SMPR2_SMP_SET             ((uint32_t)0x00000007)
    144          #define SMPR3_SMP_SET             ((uint32_t)0x00000007) 
    145          #define SMPR0_SMP_SET             ((uint32_t)0x00000007)
    146          
    147          /* ADC JDRx registers offset */
    148          #define JDR_OFFSET                ((uint8_t)0x30)   
    149            
    150          /* ADC CCR register Mask */
    151          #define CR_CLEAR_MASK             ((uint32_t)0xFFFCFFFF) 
    152          
    153          /* Private macro -------------------------------------------------------------*/
    154          /* Private variables ---------------------------------------------------------*/
    155          /* Private function prototypes -----------------------------------------------*/
    156          /* Private functions ---------------------------------------------------------*/
    157          
    158          /** @defgroup ADC_Private_Functions
    159            * @{
    160            */
    161          
    162          /** @defgroup ADC_Group1 Initialization and Configuration functions
    163           *  @brief   Initialization and Configuration functions.
    164           *
    165          @verbatim    
    166           ===============================================================================
    167                    ##### Initialization and Configuration functions #####
    168           ===============================================================================
    169              [..] This section provides functions allowing to:
    170                  (+) Initialize and configure the ADC Prescaler.
    171                  (+) ADC Conversion Resolution (12bit..6bit).
    172                  (+) Scan Conversion Mode (multichannel or one channel) for regular group.
    173                  (+) ADC Continuous Conversion Mode (Continuous or Single conversion) for 
    174                      regular group.
    175                  (+) External trigger Edge and source of regular group.
    176                  (+) Converted data alignment (left or right).
    177                  (+) The number of ADC conversions that will be done using the sequencer 
    178                      for regular channel group.
    179                  (+) Enable or disable the ADC peripheral.
    180              
    181          @endverbatim
    182            * @{
    183            */
    184          
    185          /**
    186            * @brief  Deinitializes ADC1 peripheral registers to their default reset values.
    187            * @param  None
    188            * @retval None
    189            */
    190          void ADC_DeInit(ADC_TypeDef* ADCx)
    191          {
    192            /* Check the parameters */
    193            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    194          
    195            if(ADCx == ADC1)
    196            {
    197              /* Enable ADC1 reset state */
    198              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
    199              /* Release ADC1 from reset state */
    200              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
    201            }
    202          }
    203          
    204          /**
    205            * @brief  Initializes the ADCx peripheral according to the specified parameters
    206            *         in the ADC_InitStruct.
    207            * @note   This function is used to configure the global features of the ADC ( 
    208            *         Resolution and Data Alignment), however, the rest of the configuration
    209            *         parameters are specific to the regular channels group (scan mode 
    210            *         activation, continuous mode activation, External trigger source and 
    211            *         edge, number of conversion in the regular channels group sequencer).
    212            * @param  ADCx: where x can be 1 to select the ADC peripheral.
    213            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains 
    214            *         the configuration information for the specified ADC peripheral.
    215            * @retval None
    216            */
    217          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)               
    218          {
    219            uint32_t tmpreg1 = 0;
    220            uint8_t tmpreg2 = 0;
    221            
    222            /* Check the parameters */
    223            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    224            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
    225            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    226            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
    227            assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
    228            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
    229            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    230            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
    231            
    232            /*---------------------------- ADCx CR1 Configuration -----------------*/
    233            /* Get the ADCx CR1 value */
    234            tmpreg1 = ADCx->CR1;
    235            /* Clear RES and SCAN bits */ 
    236            tmpreg1 &= CR1_CLEAR_MASK;
    237            /* Configure ADCx: scan conversion mode and resolution */
    238            /* Set SCAN bit according to ADC_ScanConvMode value */
    239            /* Set RES bit according to ADC_Resolution value */ 
    240            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | ADC_InitStruct->ADC_Resolution);
    241            /* Write to ADCx CR1 */
    242            ADCx->CR1 = tmpreg1;
    243            
    244            /*---------------------------- ADCx CR2 Configuration -----------------*/
    245            /* Get the ADCx CR2 value */
    246            tmpreg1 = ADCx->CR2;
    247            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    248            tmpreg1 &= CR2_CLEAR_MASK;
    249            /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
    250            /* Set ALIGN bit according to ADC_DataAlign value */
    251            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    252            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    253            /* Set CONT bit according to ADC_ContinuousConvMode value */
    254            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
    255                        ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    256            /* Write to ADCx CR2 */
    257            ADCx->CR2 = tmpreg1;
    258            
    259            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    260            /* Get the ADCx SQR1 value */
    261            tmpreg1 = ADCx->SQR1;
    262            /* Clear L bits */
    263            tmpreg1 &= SQR1_L_RESET;
    264            /* Configure ADCx: regular channel sequence length */
    265            /* Set L bits according to ADC_NbrOfConversion value */ 
    266            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
    267            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
    268            /* Write to ADCx SQR1 */
    269            ADCx->SQR1 = tmpreg1;
    270          }
    271          
    272          /**
    273            * @brief  Fills each ADC_InitStruct member with its default value.
    274            * @note   This function is used to initialize the global features of the ADC ( 
    275            *         Resolution and Data Alignment), however, the rest of the configuration
    276            *         parameters are specific to the regular channels group (scan mode 
    277            *         activation, continuous mode activation, External trigger source and 
    278            *         edge, number of conversion in the regular channels group sequencer).
    279            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    280            *         be initialized.
    281            * @retval None
    282            */
    283          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)                            
    284          {
    285            /* Reset ADC init structure parameters values */
    286            /* Initialize the ADC_Resolution member */
    287            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
    288          
    289            /* Initialize the ADC_ScanConvMode member */
    290            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    291          
    292            /* Initialize the ADC_ContinuousConvMode member */
    293            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    294          
    295            /* Initialize the ADC_ExternalTrigConvEdge member */
    296            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
    297          
    298            /* Initialize the ADC_ExternalTrigConv member */
    299            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
    300          
    301            /* Initialize the ADC_DataAlign member */
    302            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    303          
    304            /* Initialize the ADC_NbrOfConversion member */
    305            ADC_InitStruct->ADC_NbrOfConversion = 1;
    306          }
    307          
    308          /**
    309            * @brief  Initializes the ADCs peripherals according to the specified parameters
    310            *          in the ADC_CommonInitStruct.
    311            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    312            *         that contains the configuration information (Prescaler) for ADC1 peripheral.
    313            * @retval None
    314            */
    315          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                           
    316          {
    317            uint32_t tmpreg = 0;
    318            
    319            /* Check the parameters */
    320            assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
    321          
    322            /*---------------------------- ADC CCR Configuration -----------------*/
    323            /* Get the ADC CCR value */
    324            tmpreg = ADC->CCR;
    325          
    326            /* Clear ADCPRE bit */ 
    327            tmpreg &= CR_CLEAR_MASK;
    328            
    329            /* Configure ADCx: ADC prescaler according to ADC_Prescaler */                
    330            tmpreg |= (uint32_t)(ADC_CommonInitStruct->ADC_Prescaler);        
    331                          
    332            /* Write to ADC CCR */
    333            ADC->CCR = tmpreg;
    334          }
    335          
    336          /**
    337            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    338            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    339            *         which will be initialized.
    340            * @retval None
    341            */
    342          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                      
    343          {
    344            /* Reset ADC init structure parameters values */
    345            /* Initialize the ADC_Prescaler member */
    346            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div1;
    347          }
    348          
    349          /**
    350            * @brief  Enables or disables the specified ADC peripheral.
    351            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    352            * @param  NewState: new state of the ADCx peripheral.
    353            *         This parameter can be: ENABLE or DISABLE.
    354            * @retval None
    355            */
    356          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    357          {
    358            /* Check the parameters */
    359            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    360            assert_param(IS_FUNCTIONAL_STATE(NewState));
    361          
    362            if (NewState != DISABLE)
    363            {
    364              /* Set the ADON bit to wake up the ADC from power down mode */
    365              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
    366            }
    367            else
    368            {
    369              /* Disable the selected ADC peripheral */
    370              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
    371            }
    372          }
    373          
    374          /**
    375            * @brief  Selects the specified ADC Channels Bank.
    376            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    377            * @param  ADC_Bank: ADC Channels Bank.
    378            *     @arg ADC_Bank_A: ADC Channels Bank A.
    379            *     @arg ADC_Bank_B: ADC Channels Bank B.
    380            * @retval None
    381            */
    382          void ADC_BankSelection(ADC_TypeDef* ADCx, uint8_t ADC_Bank)
    383          {
    384            /* Check the parameters */
    385            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    386            assert_param(IS_ADC_BANK(ADC_Bank));
    387          
    388            if (ADC_Bank != ADC_Bank_A)
    389            {
    390              /* Set the ADC_CFG bit to select the ADC Bank B channels */
    391              ADCx->CR2 |= (uint32_t)ADC_CR2_CFG;
    392            }
    393            else
    394            {
    395              /* Reset the ADC_CFG bit to select the ADC Bank A channels */
    396              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CFG);
    397            }
    398          }
    399          
    400          /**
    401            * @}
    402            */
    403          
    404          /** @defgroup ADC_Group2 Power saving functions
    405           *  @brief   Power saving functions 
    406           *
    407          @verbatim   
    408           ===============================================================================
    409                              ##### Power saving functions #####
    410           ===============================================================================
    411              [..] This section provides functions allowing to reduce power consumption.
    412              [..] The two function must be combined to get the maximal benefits:
    413                   When the ADC frequency is higher than the CPU one, it is recommended to:
    414                   (#) Insert a freeze delay :
    415                       ==> using ADC_DelaySelectionConfig(ADC1, ADC_DelayLength_Freeze).
    416                   (#) Enable the power down in Idle and Delay phases :
    417                       ==> using ADC_PowerDownCmd(ADC1, ADC_PowerDown_Idle_Delay, ENABLE).
    418          
    419          @endverbatim
    420            * @{
    421            */
    422          
    423          /**
    424            * @brief  Enables or disables the ADC Power Down during Delay and/or Idle phase.
    425            * @note   ADC power-on and power-off can be managed by hardware to cut the 
    426            *         consumption when the ADC is not converting.
    427            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    428            * @param  ADC_PowerDown: The ADC power down configuration.
    429            *         This parameter can be one of the following values:
    430            *     @arg ADC_PowerDown_Delay:      ADC is powered down during delay phase.
    431            *     @arg ADC_PowerDown_Idle:       ADC is powered down during Idle phase.
    432            *     @arg ADC_PowerDown_Idle_Delay: ADC is powered down during Delay and Idle phases.
    433            * @note   The ADC can be powered down:
    434            * @note   During the hardware delay insertion (using the ADC_PowerDown_Delay
    435            *           parameter).
    436            *           => The ADC is powered up again at the end of the delay.
    437            * @note   During the ADC is waiting for a trigger event ( using the 
    438            *           ADC_PowerDown_Idle parameter).
    439            *           => The ADC is powered up at the next trigger event.
    440            * @note   During the hardware delay insertion or the ADC is waiting for a 
    441            *           trigger event (using the ADC_PowerDown_Idle_Delay parameter).
    442            *            => The ADC is powered up only at the end of the delay and at the
    443            *              next trigger event.
    444            * @param  NewState: new state of the ADCx power down.
    445            *         This parameter can be: ENABLE or DISABLE.
    446            * @retval None
    447            */
    448          void ADC_PowerDownCmd(ADC_TypeDef* ADCx, uint32_t ADC_PowerDown, FunctionalState NewState)
    449          {
    450            /* Check the parameters */
    451            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    452            assert_param(IS_FUNCTIONAL_STATE(NewState));
    453            assert_param(IS_ADC_POWER_DOWN(ADC_PowerDown));
    454            
    455            if (NewState != DISABLE)
    456            {
    457              /* Enable the ADC power-down during Delay and/or Idle phase */
    458              ADCx->CR1 |= ADC_PowerDown;
    459            }
    460            else
    461            {
    462              /* Disable The ADC power-down during Delay and/or Idle phase */
    463              ADCx->CR1 &= (uint32_t)~ADC_PowerDown;
    464            }
    465          }
    466          
    467          /**
    468            * @brief  Defines the length of the delay which is applied after a conversion 
    469            *         or a sequence of conversion.
    470            * @note   When the CPU clock is not fast enough to manage the data rate, a 
    471            *         Hardware delay can be introduced between ADC conversions to reduce 
    472            *         this data rate.
    473            * @note   The Hardware delay is inserted after :
    474            *         - each regular conversion.
    475            *         - after each sequence of injected conversions.
    476            * @note   No Hardware delay is inserted between conversions of different groups.
    477            * @note   When the hardware delay is not enough, the Freeze Delay Mode can be 
    478            *         selected and a new conversion can start only if all the previous data 
    479            *         of the same group have been treated:
    480            *         - for a regular conversion: once the ADC conversion data register has 
    481            *           been read (using ADC_GetConversionValue() function) or if the EOC 
    482            *           Flag has been cleared (using ADC_ClearFlag() function).
    483            *         - for an injected conversion: when the JEOC bit has been cleared 
    484            *           (using ADC_ClearFlag() function).
    485            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    486            * @param  ADC_DelayLength: The length of delay which is applied after a 
    487            *         conversion or a sequence of conversion. 
    488            *   This parameter can be one of the following values:
    489            *     @arg ADC_DelayLength_None: No delay.
    490            *     @arg ADC_DelayLength_Freeze: Delay until the converted data has been read.
    491            *     @arg ADC_DelayLength_7Cycles: Delay length equal to 7 APB clock cycles.
    492            *     @arg ADC_DelayLength_15Cycles: Delay length equal to 15 APB clock cycles	
    493            *     @arg ADC_DelayLength_31Cycles: Delay length equal to 31 APB clock cycles	
    494            *     @arg ADC_DelayLength_63Cycles: Delay length equal to 63 APB clock cycles	
    495            *     @arg ADC_DelayLength_127Cycles: Delay length equal to 127 APB clock cycles	
    496            *     @arg ADC_DelayLength_255Cycles: Delay length equal to 255 APB clock cycles	
    497            * @retval None
    498            */
    499          void ADC_DelaySelectionConfig(ADC_TypeDef* ADCx, uint8_t ADC_DelayLength)
    500          {
    501            uint32_t tmpreg = 0;
    502             
    503            /* Check the parameters */
    504            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    505            assert_param(IS_ADC_DELAY_LENGTH(ADC_DelayLength));
    506          
    507            /* Get the old register value */    
    508            tmpreg = ADCx->CR2;
    509            /* Clear the old delay length */
    510            tmpreg &= CR2_DELS_RESET;
    511            /* Set the delay length */
    512            tmpreg |= ADC_DelayLength;
    513            /* Store the new register value */
    514            ADCx->CR2 = tmpreg;
    515          
    516          }
    517          
    518          /**
    519            * @}
    520            */
    521          
    522          /** @defgroup ADC_Group3 Analog Watchdog configuration functions
    523           *  @brief   Analog Watchdog configuration functions. 
    524           *
    525          @verbatim   
    526           ===============================================================================
    527                             ##### Analog Watchdog configuration functions #####
    528           ===============================================================================  
    529              [..] This section provides functions allowing to configure the Analog Watchdog
    530                   (AWD) feature in the ADC.
    531              [..] A typical configuration Analog Watchdog is done following these steps :
    532                   (#) the ADC guarded channel(s) is (are) selected using the 
    533                       ADC_AnalogWatchdogSingleChannelConfig() function.
    534                   (#) The Analog watchdog lower and higher threshold are configured using 
    535                       the ADC_AnalogWatchdogThresholdsConfig() function.
    536                   (#) The Analog watchdog is enabled and configured to enable the check, 
    537                       on one or more channels, using the  ADC_AnalogWatchdogCmd() function.
    538          
    539          @endverbatim
    540            * @{
    541            */
    542            
    543          /**
    544            * @brief  Enables or disables the analog watchdog on single/all regular
    545            *         or injected channels.
    546            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    547            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    548            *   This parameter can be one of the following values:
    549            *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single 
    550            *          regular channel.
    551            *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single 
    552            *          injected channel.
    553            *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a 
    554            *          single regular or injected channel.
    555            *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular 
    556            *          channel.
    557            *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected 
    558            *          channel.
    559            *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all 
    560            *           regular and injected channels.
    561            *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog.
    562            * @retval None	  
    563            */
    564          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    565          {
    566            uint32_t tmpreg = 0;
    567          
    568            /* Check the parameters */
    569            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    570            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
    571          
    572            /* Get the old register value */
    573            tmpreg = ADCx->CR1;
    574            /* Clear AWDEN, JAWDEN and AWDSGL bits */   
    575            tmpreg &= CR1_AWDMODE_RESET;
    576            /* Set the analog watchdog enable mode */
    577            tmpreg |= ADC_AnalogWatchdog;
    578            /* Store the new register value */
    579            ADCx->CR1 = tmpreg;
    580          }
    581          
    582          /**
    583            * @brief  Configures the high and low thresholds of the analog watchdog.
    584            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    585            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    586            *         This parameter must be a 12bit value.
    587            * @param  LowThreshold: the ADC analog watchdog Low threshold value.
    588            *         This parameter must be a 12bit value.
    589            * @retval None
    590            */
    591          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    592                                                  uint16_t LowThreshold)
    593          {
    594            /* Check the parameters */
    595            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    596            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    597            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    598          
    599            /* Set the ADCx high threshold */
    600            ADCx->HTR = HighThreshold;
    601            /* Set the ADCx low threshold */
    602            ADCx->LTR = LowThreshold;
    603          }
    604          
    605          /**
    606            * @brief  Configures the analog watchdog guarded single channel.
    607            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    608            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    609            *   This parameter can be one of the following values:
    610            *     @arg ADC_Channel_0: ADC Channel0 selected
    611            *     @arg ADC_Channel_1: ADC Channel1 selected
    612            *     @arg ADC_Channel_2: ADC Channel2 selected
    613            *     @arg ADC_Channel_3: ADC Channel3 selected
    614            *     @arg ADC_Channel_4: ADC Channel4 selected
    615            *     @arg ADC_Channel_5: ADC Channel5 selected
    616            *     @arg ADC_Channel_6: ADC Channel6 selected
    617            *     @arg ADC_Channel_7: ADC Channel7 selected
    618            *     @arg ADC_Channel_8: ADC Channel8 selected
    619            *     @arg ADC_Channel_9: ADC Channel9 selected
    620            *     @arg ADC_Channel_10: ADC Channel10 selected
    621            *     @arg ADC_Channel_11: ADC Channel11 selected
    622            *     @arg ADC_Channel_12: ADC Channel12 selected
    623            *     @arg ADC_Channel_13: ADC Channel13 selected
    624            *     @arg ADC_Channel_14: ADC Channel14 selected
    625            *     @arg ADC_Channel_15: ADC Channel15 selected
    626            *     @arg ADC_Channel_16: ADC Channel16 selected
    627            *     @arg ADC_Channel_17: ADC Channel17 selected
    628            *     @arg ADC_Channel_18: ADC Channel18 selected
    629            *     @arg ADC_Channel_19: ADC Channel19 selected
    630            *     @arg ADC_Channel_20: ADC Channel20 selected
    631            *     @arg ADC_Channel_21: ADC Channel21 selected
    632            *     @arg ADC_Channel_22: ADC Channel22 selected
    633            *     @arg ADC_Channel_23: ADC Channel23 selected
    634            *     @arg ADC_Channel_24: ADC Channel24 selected
    635            *     @arg ADC_Channel_25: ADC Channel25 selected
    636            *     @arg ADC_Channel_27: ADC Channel27 selected
    637            *     @arg ADC_Channel_28: ADC Channel28 selected
    638            *     @arg ADC_Channel_29: ADC Channel29 selected
    639            *     @arg ADC_Channel_30: ADC Channel30 selected
    640            *     @arg ADC_Channel_31: ADC Channel31 selected
    641            *     @arg ADC_Channel_0b: ADC Channel0b selected
    642            *     @arg ADC_Channel_1b: ADC Channel1b selected
    643            *     @arg ADC_Channel_2b: ADC Channel2b selected
    644            *     @arg ADC_Channel_3b: ADC Channel3b selected
    645            *     @arg ADC_Channel_6b: ADC Channel6b selected
    646            *     @arg ADC_Channel_7b: ADC Channel7b selected
    647            *     @arg ADC_Channel_8b: ADC Channel8b selected
    648            *     @arg ADC_Channel_9b: ADC Channel9b selected
    649            *     @arg ADC_Channel_10b: ADC Channel10b selected
    650            *     @arg ADC_Channel_11b: ADC Channel11b selected
    651            *     @arg ADC_Channel_12b: ADC Channel12b selected
    652            * @retval None
    653            */
    654          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    655          {
    656            uint32_t tmpreg = 0;
    657          
    658            /* Check the parameters */
    659            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    660            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    661          
    662            /* Get the old register value */
    663            tmpreg = ADCx->CR1;
    664            /* Clear the Analog watchdog channel select bits */
    665            tmpreg &= CR1_AWDCH_RESET;
    666            /* Set the Analog watchdog channel */
    667            tmpreg |= ADC_Channel;
    668            /* Store the new register value */
    669            ADCx->CR1 = tmpreg;
    670          }
    671          
    672          /**
    673            * @}
    674            */
    675          
    676          /** @defgroup ADC_Group4 Temperature Sensor & Vrefint (Voltage Reference internal) management function
    677           *  @brief   Temperature Sensor & Vrefint (Voltage Reference internal) management function.
    678           *
    679          @verbatim   
    680           =========================================================================================
    681           ##### Temperature Sensor and Vrefint (Voltage Reference internal) management function #####
    682           =========================================================================================
    683              [..] This section provides a function allowing to enable/ disable the internal 
    684                   connections between the ADC and the Temperature Sensor and the Vrefint 
    685                   source.
    686              [..] A typical configuration to get the Temperature sensor and Vrefint channels 
    687                   voltages is done following these steps :
    688                   (#) Enable the internal connection of Temperature sensor and Vrefint sources 
    689                       with the ADC channels using ADC_TempSensorVrefintCmd() function.
    690                   (#) select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    691                       ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions.
    692                   (#) Get the voltage values, using ADC_GetConversionValue() or 
    693                       ADC_GetInjectedConversionValue().
    694          @endverbatim
    695            * @{
    696            */
    697            
    698          /**
    699            * @brief  Enables or disables the temperature sensor and Vrefint channel.
    700            * @param  NewState: new state of the temperature sensor and Vref int channels.
    701            *         This parameter can be: ENABLE or DISABLE.
    702            * @retval None
    703            */
    704          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    705          {
    706            /* Check the parameters */
    707            assert_param(IS_FUNCTIONAL_STATE(NewState));
    708          
    709            if (NewState != DISABLE)
    710            {
    711              /* Enable the temperature sensor and Vrefint channel*/
    712              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
    713            }
    714            else
    715            {
    716              /* Disable the temperature sensor and Vrefint channel*/
    717              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
    718            }
    719          }
    720          
    721          /**
    722            * @}
    723            */
    724          
    725          /** @defgroup ADC_Group5 Regular Channels Configuration functions
    726           *  @brief   Regular Channels Configuration functions.
    727           *
    728          @verbatim   
    729           ===============================================================================
    730                      ##### Regular Channels Configuration functions #####
    731           ===============================================================================
    732              [..] This section provides functions allowing to manage the ADC regular channels,
    733                   it is composed of 2 sub sections :
    734                   (#) Configuration and management functions for regular channels: This 
    735                       subsection provides functions allowing to configure the ADC regular 
    736                       channels :
    737                       (++) Configure the rank in the regular group sequencer for each channel.
    738                       (++) Configure the sampling time for each channel.
    739                       (++) select the conversion Trigger for regular channels.
    740                       (++) select the desired EOC event behavior configuration.
    741                       (++) Activate the continuous Mode  (*).
    742                       (++) Activate the Discontinuous Mode.
    743                       -@@- Please Note that the following features for regular channels are 
    744                            configurated using the ADC_Init() function : 
    745                            (+@@) scan mode activation.
    746                            (+@@) continuous mode activation (**).
    747                            (+@@) External trigger source.
    748                            (+@@) External trigger edge.
    749                            (+@@) number of conversion in the regular channels group sequencer.
    750                       -@@- (*) and (**) are performing the same configuration.
    751                   (#) Get the conversion data: This subsection provides an important function 
    752                       in the ADC peripheral since it returns the converted data of the current 
    753                       regular channel. When the Conversion value is read, the EOC Flag is 
    754                       automatically cleared.
    755          @endverbatim
    756            * @{
    757            */
    758          
    759          /**
    760            * @brief  Configures for the selected ADC regular channel its corresponding
    761            *         rank in the sequencer and its sampling time.
    762            * @param  ADCx: where x can be 1 to select the ADC peripheral.
    763            * @param  ADC_Channel: the ADC channel to configure.
    764            *   This parameter can be one of the following values:
    765            *     @arg ADC_Channel_0: ADC Channel0 selected
    766            *     @arg ADC_Channel_1: ADC Channel1 selected
    767            *     @arg ADC_Channel_2: ADC Channel2 selected
    768            *     @arg ADC_Channel_3: ADC Channel3 selected
    769            *     @arg ADC_Channel_4: ADC Channel4 selected
    770            *     @arg ADC_Channel_5: ADC Channel5 selected
    771            *     @arg ADC_Channel_6: ADC Channel6 selected
    772            *     @arg ADC_Channel_7: ADC Channel7 selected
    773            *     @arg ADC_Channel_8: ADC Channel8 selected
    774            *     @arg ADC_Channel_9: ADC Channel9 selected
    775            *     @arg ADC_Channel_10: ADC Channel10 selected
    776            *     @arg ADC_Channel_11: ADC Channel11 selected
    777            *     @arg ADC_Channel_12: ADC Channel12 selected
    778            *     @arg ADC_Channel_13: ADC Channel13 selected
    779            *     @arg ADC_Channel_14: ADC Channel14 selected
    780            *     @arg ADC_Channel_15: ADC Channel15 selected
    781            *     @arg ADC_Channel_16: ADC Channel16 selected
    782            *     @arg ADC_Channel_17: ADC Channel17 selected
    783            *     @arg ADC_Channel_18: ADC Channel18 selected 
    784            *     @arg ADC_Channel_19: ADC Channel19 selected
    785            *     @arg ADC_Channel_20: ADC Channel20 selected
    786            *     @arg ADC_Channel_21: ADC Channel21 selected
    787            *     @arg ADC_Channel_22: ADC Channel22 selected
    788            *     @arg ADC_Channel_23: ADC Channel23 selected
    789            *     @arg ADC_Channel_24: ADC Channel24 selected
    790            *     @arg ADC_Channel_25: ADC Channel25 selected
    791            *     @arg ADC_Channel_27: ADC Channel27 selected
    792            *     @arg ADC_Channel_28: ADC Channel28 selected
    793            *     @arg ADC_Channel_29: ADC Channel29 selected
    794            *     @arg ADC_Channel_30: ADC Channel30 selected
    795            *     @arg ADC_Channel_31: ADC Channel31 selected 
    796            *     @arg ADC_Channel_0b: ADC Channel0b selected
    797            *     @arg ADC_Channel_1b: ADC Channel1b selected
    798            *     @arg ADC_Channel_2b: ADC Channel2b selected
    799            *     @arg ADC_Channel_3b: ADC Channel3b selected
    800            *     @arg ADC_Channel_6b: ADC Channel6b selected
    801            *     @arg ADC_Channel_7b: ADC Channel7b selected
    802            *     @arg ADC_Channel_8b: ADC Channel8b selected
    803            *     @arg ADC_Channel_9b: ADC Channel9b selected
    804            *     @arg ADC_Channel_10b: ADC Channel10b selected
    805            *     @arg ADC_Channel_11b: ADC Channel11b selected
    806            *     @arg ADC_Channel_12b: ADC Channel12b selected   
    807            * @param  Rank: The rank in the regular group sequencer. This parameter
    808            *               must be between 1 to 28.
    809            * @param  ADC_SampleTime: The sample time value to be set for the selected 
    810            *         channel.
    811            *   This parameter can be one of the following values:
    812            *     @arg ADC_SampleTime_4Cycles: Sample time equal to 4 cycles
    813            *     @arg ADC_SampleTime_9Cycles: Sample time equal to 9 cycles
    814            *     @arg ADC_SampleTime_16Cycles: Sample time equal to 16 cycles
    815            *     @arg ADC_SampleTime_24Cycles: Sample time equal to 24 cycles	
    816            *     @arg ADC_SampleTime_48Cycles: Sample time equal to 48 cycles	
    817            *     @arg ADC_SampleTime_96Cycles: Sample time equal to 96 cycles	
    818            *     @arg ADC_SampleTime_192Cycles: Sample time equal to 192 cycles	
    819            *     @arg ADC_SampleTime_384Cycles: Sample time equal to 384 cycles	
    820            * @retval None
    821            */
    822          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    823          {
    824            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    825          
    826            /* Check the parameters */
    827            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    828            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    829            assert_param(IS_ADC_REGULAR_RANK(Rank));
    830            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    831          
    832            /* If ADC_Channel_30 or ADC_Channel_31 is selected */
    833            if (ADC_Channel > ADC_Channel_29)
    834            {
    835              /* Get the old register value */
    836              tmpreg1 = ADCx->SMPR0;
    837              /* Calculate the mask to clear */
    838              tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
    839              /* Clear the old sample time */
    840              tmpreg1 &= ~tmpreg2;
    841              /* Calculate the mask to set */
    842              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
    843              /* Set the new sample time */
    844              tmpreg1 |= tmpreg2;
    845              /* Store the new register value */
    846              ADCx->SMPR0 = tmpreg1;
    847            }
    848            /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
    849            else if (ADC_Channel > ADC_Channel_19)
    850            {
    851              /* Get the old register value */
    852              tmpreg1 = ADCx->SMPR1;
    853              /* Calculate the mask to clear */
    854              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
    855              /* Clear the old sample time */
    856              tmpreg1 &= ~tmpreg2;
    857              /* Calculate the mask to set */
    858              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
    859              /* Set the new sample time */
    860              tmpreg1 |= tmpreg2;
    861              /* Store the new register value */
    862              ADCx->SMPR1 = tmpreg1;
    863            }
    864            /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
    865            else if (ADC_Channel > ADC_Channel_9)
    866            {
    867              /* Get the old register value */
    868              tmpreg1 = ADCx->SMPR2;
    869              /* Calculate the mask to clear */
    870              tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
    871              /* Clear the old sample time */
    872              tmpreg1 &= ~tmpreg2;
    873              /* Calculate the mask to set */
    874              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    875              /* Set the new sample time */
    876              tmpreg1 |= tmpreg2;
    877              /* Store the new register value */
    878              ADCx->SMPR2 = tmpreg1;
    879            }
    880            else /* ADC_Channel include in ADC_Channel_[0..9] */
    881            {
    882              /* Get the old register value */
    883              tmpreg1 = ADCx->SMPR3;
    884              /* Calculate the mask to clear */
    885              tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
    886              /* Clear the old sample time */
    887              tmpreg1 &= ~tmpreg2;
    888              /* Calculate the mask to set */
    889              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    890              /* Set the new sample time */
    891              tmpreg1 |= tmpreg2;
    892              /* Store the new register value */
    893              ADCx->SMPR3 = tmpreg1;
    894            }
    895            /* For Rank 1 to 6 */
    896            if (Rank < 7)
    897            {
    898              /* Get the old register value */
    899              tmpreg1 = ADCx->SQR5;
    900              /* Calculate the mask to clear */
    901              tmpreg2 = SQR5_SQ_SET << (5 * (Rank - 1));
    902              /* Clear the old SQx bits for the selected rank */
    903              tmpreg1 &= ~tmpreg2;
    904              /* Calculate the mask to set */
    905              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    906              /* Set the SQx bits for the selected rank */
    907              tmpreg1 |= tmpreg2;
    908              /* Store the new register value */
    909              ADCx->SQR5 = tmpreg1;
    910            }
    911            /* For Rank 7 to 12 */
    912            else if (Rank < 13)
    913            {
    914              /* Get the old register value */
    915              tmpreg1 = ADCx->SQR4;
    916              /* Calculate the mask to clear */
    917              tmpreg2 = SQR4_SQ_SET << (5 * (Rank - 7));
    918              /* Clear the old SQx bits for the selected rank */
    919              tmpreg1 &= ~tmpreg2;
    920              /* Calculate the mask to set */
    921              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    922              /* Set the SQx bits for the selected rank */
    923              tmpreg1 |= tmpreg2;
    924              /* Store the new register value */
    925              ADCx->SQR4 = tmpreg1;
    926            }  
    927            /* For Rank 13 to 18 */
    928            else if (Rank < 19)
    929            {
    930              /* Get the old register value */
    931              tmpreg1 = ADCx->SQR3;
    932              /* Calculate the mask to clear */
    933              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 13));
    934              /* Clear the old SQx bits for the selected rank */
    935              tmpreg1 &= ~tmpreg2;
    936              /* Calculate the mask to set */
    937              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    938              /* Set the SQx bits for the selected rank */
    939              tmpreg1 |= tmpreg2;
    940              /* Store the new register value */
    941              ADCx->SQR3 = tmpreg1;
    942            }
    943              
    944            /* For Rank 19 to 24 */
    945            else if (Rank < 25)
    946            {
    947              /* Get the old register value */
    948              tmpreg1 = ADCx->SQR2;
    949              /* Calculate the mask to clear */
    950              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 19));
    951              /* Clear the old SQx bits for the selected rank */
    952              tmpreg1 &= ~tmpreg2;
    953              /* Calculate the mask to set */
    954              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 19));
    955              /* Set the SQx bits for the selected rank */
    956              tmpreg1 |= tmpreg2;
    957              /* Store the new register value */
    958              ADCx->SQR2 = tmpreg1;
    959            }   
    960            
    961            /* For Rank 25 to 28 */
    962            else
    963            {
    964              /* Get the old register value */
    965              tmpreg1 = ADCx->SQR1;
    966              /* Calculate the mask to clear */
    967              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 25));
    968              /* Clear the old SQx bits for the selected rank */
    969              tmpreg1 &= ~tmpreg2;
    970              /* Calculate the mask to set */
    971              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 25));
    972              /* Set the SQx bits for the selected rank */
    973              tmpreg1 |= tmpreg2;
    974              /* Store the new register value */
    975              ADCx->SQR1 = tmpreg1;
    976            }
    977          }
    978          
    979          /**
    980            * @brief  Enables the selected ADC software start conversion of the regular channels.
    981            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    982            * @retval None
    983            */
    984          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    985          {
    986            /* Check the parameters */
    987            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    988          
    989            /* Enable the selected ADC conversion for regular group */
    990            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
    991          }
    992          
    993          /**
    994            * @brief  Gets the selected ADC Software start regular conversion Status.
    995            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    996            * @retval The new state of ADC software start conversion (SET or RESET).
    997            */
    998          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    999          {
   1000            FlagStatus bitstatus = RESET;
   1001          
   1002            /* Check the parameters */
   1003            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1004          
   1005            /* Check the status of SWSTART bit */
   1006            if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
   1007            {
   1008              /* SWSTART bit is set */
   1009              bitstatus = SET;
   1010            }
   1011            else
   1012            {
   1013              /* SWSTART bit is reset */
   1014              bitstatus = RESET;
   1015            }
   1016            /* Return the SWSTART bit status */
   1017            return  bitstatus;
   1018          }
   1019          
   1020          /**
   1021            * @brief  Enables or disables the EOC on each regular channel conversion.
   1022            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1023            * @param  NewState: new state of the selected ADC EOC flag rising
   1024            *    This parameter can be: ENABLE or DISABLE.
   1025            * @retval None
   1026            */
   1027          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1028          {
   1029            /* Check the parameters */
   1030            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1031            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1032          
   1033            if (NewState != DISABLE)
   1034            {
   1035              /* Enable the selected ADC EOC rising on each regular channel conversion */
   1036              ADCx->CR2 |= ADC_CR2_EOCS;
   1037            }
   1038            else
   1039            {
   1040              /* Disable the selected ADC EOC rising on each regular channel conversion */
   1041              ADCx->CR2 &= (uint32_t)~ADC_CR2_EOCS;
   1042            }
   1043          }
   1044          
   1045          /**
   1046            * @brief  Enables or disables the ADC continuous conversion mode.
   1047            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1048            * @param  NewState: new state of the selected ADC continuous conversion mode.
   1049            *         This parameter can be: ENABLE or DISABLE.
   1050            * @retval None
   1051            */
   1052          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1053          {
   1054            /* Check the parameters */
   1055            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1056            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1057          
   1058            if (NewState != DISABLE)
   1059            {
   1060              /* Enable the selected ADC continuous conversion mode */
   1061              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
   1062            }
   1063            else
   1064            {
   1065              /* Disable the selected ADC continuous conversion mode */
   1066              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
   1067            }
   1068          }
   1069          
   1070          /**
   1071            * @brief  Configures the discontinuous mode for the selected ADC regular
   1072            *         group channel.
   1073            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1074            * @param  Number: specifies the discontinuous mode regular channel count value.
   1075            *         This number must be between 1 and 8.
   1076            * @retval None
   1077            */
   1078          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
   1079          {
   1080            uint32_t tmpreg1 = 0;
   1081            uint32_t tmpreg2 = 0;
   1082          
   1083            /* Check the parameters */
   1084            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1085            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
   1086          
   1087            /* Get the old register value */
   1088            tmpreg1 = ADCx->CR1;
   1089            /* Clear the old discontinuous mode channel count */
   1090            tmpreg1 &= CR1_DISCNUM_RESET;
   1091            /* Set the discontinuous mode channel count */
   1092            tmpreg2 = Number - 1;
   1093            tmpreg1 |= tmpreg2 << 13;
   1094            /* Store the new register value */
   1095            ADCx->CR1 = tmpreg1;
   1096          }
   1097          
   1098          /**
   1099            * @brief  Enables or disables the discontinuous mode on regular group
   1100            *         channel for the specified ADC.
   1101            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1102            * @param  NewState: new state of the selected ADC discontinuous mode on regular 
   1103            *         group channel.
   1104            *         This parameter can be: ENABLE or DISABLE.
   1105            * @retval None
   1106            */
   1107          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1108          {
   1109            /* Check the parameters */
   1110            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1111            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1112          
   1113            if (NewState != DISABLE)
   1114            {
   1115              /* Enable the selected ADC regular discontinuous mode */
   1116              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
   1117            }
   1118            else
   1119            {
   1120              /* Disable the selected ADC regular discontinuous mode */
   1121              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
   1122            }
   1123          }
   1124          
   1125          /**
   1126            * @brief  Returns the last ADCx conversion result data for regular channel.
   1127            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1128            * @retval The Data conversion value.
   1129            */
   1130          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
   1131          {
   1132            /* Check the parameters */
   1133            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1134          
   1135            /* Return the selected ADC conversion value */
   1136            return (uint16_t) ADCx->DR;
   1137          }
   1138          
   1139          /**
   1140            * @}
   1141            */
   1142          
   1143          /** @defgroup ADC_Group6 Regular Channels DMA Configuration functions
   1144           *  @brief   Regular Channels DMA Configuration functions.
   1145           *
   1146          @verbatim   
   1147           ===============================================================================
   1148                    ##### Regular Channels DMA Configuration functions #####
   1149           ===============================================================================
   1150              [..] This section provides functions allowing to configure the DMA for ADC regular 
   1151                   channels.Since converted regular channel values are stored into a unique 
   1152                   data register, it is useful to use DMA for conversion of more than one 
   1153                   regular channel. This avoids the loss of the data already stored in the 
   1154                   ADC Data register.
   1155                   When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1156                   conversion of a regular channel, a DMA request is generated.
   1157              [..] Depending on the "DMA disable selection" configuration (using the 
   1158                   ADC_DMARequestAfterLastTransferCmd() function), at the end of the last DMA 
   1159                   transfer, two possibilities are allowed:
   1160                   (+) No new DMA request is issued to the DMA controller (feature DISABLED).
   1161                   (+) Requests can continue to be generated (feature ENABLED).
   1162          
   1163          @endverbatim
   1164            * @{
   1165            */
   1166          
   1167          /**
   1168            * @brief  Enables or disables the specified ADC DMA request.
   1169            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1170            * @param  NewState: new state of the selected ADC DMA transfer.
   1171            *         This parameter can be: ENABLE or DISABLE.
   1172            * @retval None
   1173            */
   1174          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1175          {
   1176            /* Check the parameters */
   1177            assert_param(IS_ADC_DMA_PERIPH(ADCx));
   1178            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1179          
   1180            if (NewState != DISABLE)
   1181            {
   1182              /* Enable the selected ADC DMA request */
   1183              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   1184            }
   1185            else
   1186            {
   1187              /* Disable the selected ADC DMA request */
   1188              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   1189            }
   1190          }
   1191          
   1192          
   1193          /**
   1194            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode).
   1195            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1196            * @param  NewState: new state of the selected ADC EOC flag rising
   1197            *         This parameter can be: ENABLE or DISABLE.
   1198            * @retval None
   1199            */
   1200          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1201          {
   1202            /* Check the parameters */
   1203            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1204            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1205          
   1206            if (NewState != DISABLE)
   1207            {
   1208              /* Enable the selected ADC DMA request after last transfer */
   1209              ADCx->CR2 |= ADC_CR2_DDS;
   1210            }
   1211            else
   1212            {
   1213              /* Disable the selected ADC DMA request after last transfer */
   1214              ADCx->CR2 &= (uint32_t)~ADC_CR2_DDS;
   1215            }
   1216          }
   1217          
   1218          /**
   1219            * @}
   1220            */
   1221          
   1222          /** @defgroup ADC_Group7 Injected channels Configuration functions
   1223           *  @brief   Injected channels Configuration functions.
   1224           *
   1225          @verbatim   
   1226           ===============================================================================
   1227                      ##### Injected channels Configuration functions #####
   1228           ===============================================================================
   1229              [..] This section provide functions allowing to configure the ADC Injected channels,
   1230                   it is composed of 2 sub sections : 
   1231                   (#) Configuration functions for Injected channels: This subsection provides 
   1232                       functions allowing to configure the ADC injected channels :
   1233                       (++) Configure the rank in the injected group sequencer for each channel.
   1234                       (++) Configure the sampling time for each channel.
   1235                       (++) Activate the Auto injected Mode.
   1236                       (++) Activate the Discontinuous Mode.
   1237                       (++) scan mode activation.
   1238                       (++) External/software trigger source.
   1239                       (++) External trigger edge.
   1240                       (++) injected channels sequencer.
   1241              
   1242                   (#) Get the Specified Injected channel conversion data: This subsection 
   1243                       provides an important function in the ADC peripheral since it returns 
   1244                       the converted data of the specific injected channel.
   1245          
   1246          @endverbatim
   1247            * @{
   1248            */ 
   1249          
   1250          /**
   1251            * @brief  Configures for the selected ADC injected channel its corresponding
   1252            *         rank in the sequencer and its sample time.
   1253            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1254            * @param  ADC_Channel: the ADC channel to configure.
   1255            *   This parameter can be one of the following values:
   1256            *     @arg ADC_Channel_0: ADC Channel0 selected
   1257            *     @arg ADC_Channel_1: ADC Channel1 selected
   1258            *     @arg ADC_Channel_2: ADC Channel2 selected
   1259            *     @arg ADC_Channel_3: ADC Channel3 selected
   1260            *     @arg ADC_Channel_4: ADC Channel4 selected
   1261            *     @arg ADC_Channel_5: ADC Channel5 selected
   1262            *     @arg ADC_Channel_6: ADC Channel6 selected
   1263            *     @arg ADC_Channel_7: ADC Channel7 selected
   1264            *     @arg ADC_Channel_8: ADC Channel8 selected
   1265            *     @arg ADC_Channel_9: ADC Channel9 selected
   1266            *     @arg ADC_Channel_10: ADC Channel10 selected
   1267            *     @arg ADC_Channel_11: ADC Channel11 selected
   1268            *     @arg ADC_Channel_12: ADC Channel12 selected
   1269            *     @arg ADC_Channel_13: ADC Channel13 selected
   1270            *     @arg ADC_Channel_14: ADC Channel14 selected
   1271            *     @arg ADC_Channel_15: ADC Channel15 selected
   1272            *     @arg ADC_Channel_16: ADC Channel16 selected
   1273            *     @arg ADC_Channel_17: ADC Channel17 selected
   1274            *     @arg ADC_Channel_18: ADC Channel18 selected 
   1275            *     @arg ADC_Channel_19: ADC Channel19 selected
   1276            *     @arg ADC_Channel_20: ADC Channel20 selected
   1277            *     @arg ADC_Channel_21: ADC Channel21 selected
   1278            *     @arg ADC_Channel_22: ADC Channel22 selected
   1279            *     @arg ADC_Channel_23: ADC Channel23 selected
   1280            *     @arg ADC_Channel_24: ADC Channel24 selected
   1281            *     @arg ADC_Channel_25: ADC Channel25 selected
   1282            *     @arg ADC_Channel_27: ADC Channel27 selected
   1283            *     @arg ADC_Channel_28: ADC Channel28 selected
   1284            *     @arg ADC_Channel_29: ADC Channel29 selected
   1285            *     @arg ADC_Channel_30: ADC Channel30 selected
   1286            *     @arg ADC_Channel_31: ADC Channel31 selected 
   1287            *     @arg ADC_Channel_0b: ADC Channel0b selected
   1288            *     @arg ADC_Channel_1b: ADC Channel1b selected
   1289            *     @arg ADC_Channel_2b: ADC Channel2b selected
   1290            *     @arg ADC_Channel_3b: ADC Channel3b selected
   1291            *     @arg ADC_Channel_6b: ADC Channel6b selected
   1292            *     @arg ADC_Channel_7b: ADC Channel7b selected
   1293            *     @arg ADC_Channel_8b: ADC Channel8b selected
   1294            *     @arg ADC_Channel_9b: ADC Channel9b selected
   1295            *     @arg ADC_Channel_10b: ADC Channel10b selected
   1296            *     @arg ADC_Channel_11b: ADC Channel11b selected
   1297            *     @arg ADC_Channel_12b: ADC Channel12b selected   
   1298            * @param  Rank: The rank in the injected group sequencer. This parameter
   1299            *         must be between 1 to 4.
   1300            * @param  ADC_SampleTime: The sample time value to be set for the selected 
   1301            *         channel. This parameter can be one of the following values:
   1302            *     @arg ADC_SampleTime_4Cycles: Sample time equal to 4 cycles
   1303            *     @arg ADC_SampleTime_9Cycles: Sample time equal to 9 cycles
   1304            *     @arg ADC_SampleTime_16Cycles: Sample time equal to 16 cycles
   1305            *     @arg ADC_SampleTime_24Cycles: Sample time equal to 24 cycles	
   1306            *     @arg ADC_SampleTime_48Cycles: Sample time equal to 48 cycles	
   1307            *     @arg ADC_SampleTime_96Cycles: Sample time equal to 96 cycles	
   1308            *     @arg ADC_SampleTime_192Cycles: Sample time equal to 192 cycles	
   1309            *     @arg ADC_SampleTime_384Cycles: Sample time equal to 384 cycles	
   1310            * @retval None
   1311            */
   1312          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1313          {
   1314            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   1315          
   1316            /* Check the parameters */
   1317            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1318            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1319            assert_param(IS_ADC_INJECTED_RANK(Rank));
   1320            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1321            
   1322            /* If ADC_Channel_30 or ADC_Channel_31 is selected */
   1323            if (ADC_Channel > ADC_Channel_29)
   1324            {
   1325              /* Get the old register value */
   1326              tmpreg1 = ADCx->SMPR0;
   1327              /* Calculate the mask to clear */
   1328              tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
   1329              /* Clear the old sample time */
   1330              tmpreg1 &= ~tmpreg2;
   1331              /* Calculate the mask to set */
   1332              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
   1333              /* Set the new sample time */
   1334              tmpreg1 |= tmpreg2;
   1335              /* Store the new register value */
   1336              ADCx->SMPR0 = tmpreg1;
   1337            }
   1338            /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
   1339            else if (ADC_Channel > ADC_Channel_19)
   1340            {
   1341              /* Get the old register value */
   1342              tmpreg1 = ADCx->SMPR1;
   1343              /* Calculate the mask to clear */
   1344              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
   1345              /* Clear the old sample time */
   1346              tmpreg1 &= ~tmpreg2;
   1347              /* Calculate the mask to set */
   1348              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
   1349              /* Set the new sample time */
   1350              tmpreg1 |= tmpreg2;
   1351              /* Store the new register value */
   1352              ADCx->SMPR1 = tmpreg1;
   1353            }  
   1354            /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
   1355            else if (ADC_Channel > ADC_Channel_9)
   1356            {
   1357              /* Get the old register value */
   1358              tmpreg1 = ADCx->SMPR2;
   1359              /* Calculate the mask to clear */
   1360              tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
   1361              /* Clear the old sample time */
   1362              tmpreg1 &= ~tmpreg2;
   1363              /* Calculate the mask to set */
   1364              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
   1365              /* Set the new sample time */
   1366              tmpreg1 |= tmpreg2;
   1367              /* Store the new register value */
   1368              ADCx->SMPR2 = tmpreg1;
   1369            }
   1370            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1371            {
   1372              /* Get the old register value */
   1373              tmpreg1 = ADCx->SMPR3;
   1374              /* Calculate the mask to clear */
   1375              tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
   1376              /* Clear the old sample time */
   1377              tmpreg1 &= ~tmpreg2;
   1378              /* Calculate the mask to set */
   1379              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   1380              /* Set the new sample time */
   1381              tmpreg1 |= tmpreg2;
   1382              /* Store the new register value */
   1383              ADCx->SMPR3 = tmpreg1;
   1384            }
   1385            
   1386            /* Rank configuration */
   1387            /* Get the old register value */
   1388            tmpreg1 = ADCx->JSQR;
   1389            /* Get JL value: Number = JL+1 */
   1390            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   1391            /* Calculate the mask to clear: ((Rank-1)+(4- (JL+1))) */ 
   1392            tmpreg2 = (uint32_t)(JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
   1393            /* Clear the old JSQx bits for the selected rank */
   1394            tmpreg1 &= ~tmpreg2;
   1395            /* Calculate the mask to set: ((Rank-1)+(4- (JL+1))) */ 
   1396            tmpreg2 = (uint32_t)(((uint32_t)(ADC_Channel)) << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
   1397            /* Set the JSQx bits for the selected rank */
   1398            tmpreg1 |= tmpreg2;
   1399            /* Store the new register value */
   1400            ADCx->JSQR = tmpreg1;
   1401          }
   1402          
   1403          /**
   1404            * @brief  Configures the sequencer length for injected channels.
   1405            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1406            * @param  Length: The sequencer length.
   1407            *         This parameter must be a number between 1 to 4.
   1408            * @retval None
   1409            */
   1410          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1411          {
   1412            uint32_t tmpreg1 = 0;
   1413            uint32_t tmpreg2 = 0;
   1414          
   1415            /* Check the parameters */
   1416            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1417            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1418            
   1419            /* Get the old register value */
   1420            tmpreg1 = ADCx->JSQR;
   1421            /* Clear the old injected sequence length JL bits */
   1422            tmpreg1 &= JSQR_JL_RESET;
   1423            /* Set the injected sequence length JL bits */
   1424            tmpreg2 = Length - 1; 
   1425            tmpreg1 |= tmpreg2 << 20;
   1426            /* Store the new register value */
   1427            ADCx->JSQR = tmpreg1;
   1428          }
   1429          
   1430          /**
   1431            * @brief  Set the injected channels conversion value offset.
   1432            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1433            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset.
   1434            *   This parameter can be one of the following values:
   1435            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected.
   1436            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected.
   1437            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected.
   1438            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected.
   1439            * @param  Offset: the offset value for the selected ADC injected channel
   1440            *         This parameter must be a 12bit value.
   1441            * @retval None
   1442            */
   1443          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1444          {
   1445            __IO uint32_t tmp = 0;
   1446            
   1447            /* Check the parameters */
   1448            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1449            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1450            assert_param(IS_ADC_OFFSET(Offset));  
   1451            
   1452            tmp = (uint32_t)ADCx;
   1453            tmp += ADC_InjectedChannel;
   1454            
   1455            /* Set the selected injected channel data offset */
   1456            *(__IO uint32_t *) tmp = (uint32_t)Offset;
   1457          }
   1458          
   1459          /**
   1460            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1461            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1462            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected 
   1463            *    conversion. This parameter can be one of the following values:
   1464            *     @arg ADC_ExternalTrigInjecConv_T9_CC1: Timer9 capture compare1 selected 
   1465            *     @arg ADC_ExternalTrigInjecConv_T9_TRGO: Timer9 TRGO event selected 
   1466            *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected
   1467            *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected
   1468            *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected
   1469            *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1470            *     @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected
   1471            *     @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1472            *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected
   1473            *     @arg ADC_ExternalTrigInjecConv_T10_CC1: Timer10 capture compare1 selected
   1474            *     @arg ADC_ExternalTrigInjecConv_T7_TRGO: Timer7 TRGO event selected
   1475            *     @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected
   1476            * @retval None
   1477            */
   1478          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1479          {
   1480            uint32_t tmpreg = 0;
   1481          
   1482            /* Check the parameters */
   1483            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1484            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   1485          
   1486            /* Get the old register value */
   1487            tmpreg = ADCx->CR2;
   1488            /* Clear the old external event selection for injected group */
   1489            tmpreg &= CR2_JEXTSEL_RESET;
   1490            /* Set the external event selection for injected group */
   1491            tmpreg |= ADC_ExternalTrigInjecConv;
   1492            /* Store the new register value */
   1493            ADCx->CR2 = tmpreg;
   1494          }
   1495          
   1496          /**
   1497            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1498            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1499            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger
   1500            *         edge to start injected conversion.
   1501            *   This parameter can be one of the following values:
   1502            *     @arg ADC_ExternalTrigConvEdge_None: external trigger disabled for 
   1503            *          injected conversion.
   1504            *     @arg ADC_ExternalTrigConvEdge_Rising: detection on rising edge
   1505            *     @arg ADC_ExternalTrigConvEdge_Falling: detection on falling edge
   1506            *     @arg ADC_ExternalTrigConvEdge_RisingFalling: detection on 
   1507            *          both rising and falling edge
   1508            * @retval None
   1509            */
   1510          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1511          {
   1512            uint32_t tmpreg = 0;
   1513          
   1514            /* Check the parameters */
   1515            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1516            assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   1517          
   1518            /* Get the old register value */
   1519            tmpreg = ADCx->CR2;
   1520            /* Clear the old external trigger edge for injected group */
   1521            tmpreg &= CR2_JEXTEN_RESET;
   1522            /* Set the new external trigger edge for injected group */
   1523            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   1524            /* Store the new register value */
   1525            ADCx->CR2 = tmpreg;
   1526          }
   1527          
   1528          /**
   1529            * @brief  Enables the selected ADC software start conversion of the injected 
   1530            *         channels.
   1531            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1532            * @retval None
   1533            */
   1534          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1535          {
   1536            /* Check the parameters */
   1537            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1538            /* Enable the selected ADC conversion for injected group */
   1539            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   1540          }
   1541          
   1542          /**
   1543            * @brief  Gets the selected ADC Software start injected conversion Status.
   1544            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1545            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1546            */
   1547          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1548          {
   1549            FlagStatus bitstatus = RESET;
   1550          
   1551            /* Check the parameters */
   1552            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1553          
   1554            /* Check the status of JSWSTART bit */
   1555            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   1556            {
   1557              /* JSWSTART bit is set */
   1558              bitstatus = SET;
   1559            }
   1560            else
   1561            {
   1562              /* JSWSTART bit is reset */
   1563              bitstatus = RESET;
   1564            }
   1565            /* Return the JSWSTART bit status */
   1566            return  bitstatus;
   1567          }
   1568          
   1569          /**
   1570            * @brief  Enables or disables the selected ADC automatic injected group
   1571            *         conversion after regular one.
   1572            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1573            * @param  NewState: new state of the selected ADC auto injected
   1574            *         conversion.
   1575            *         This parameter can be: ENABLE or DISABLE.
   1576            * @retval None
   1577            */
   1578          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1579          {
   1580            /* Check the parameters */
   1581            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1582            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1583          
   1584            if (NewState != DISABLE)
   1585            {
   1586              /* Enable the selected ADC automatic injected group conversion */
   1587              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   1588            }
   1589            else
   1590            {
   1591              /* Disable the selected ADC automatic injected group conversion */
   1592              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   1593            }
   1594          }
   1595          
   1596          /**
   1597            * @brief  Enables or disables the discontinuous mode for injected group
   1598            *         channel for the specified ADC.
   1599            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1600            * @param  NewState: new state of the selected ADC discontinuous mode
   1601            *         on injected group channel. This parameter can be: ENABLE or DISABLE.
   1602            * @retval None
   1603            */
   1604          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1605          {
   1606            /* Check the parameters */
   1607            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1608            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1609          
   1610            if (NewState != DISABLE)
   1611            {
   1612              /* Enable the selected ADC injected discontinuous mode */
   1613              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   1614            }
   1615            else
   1616            {
   1617              /* Disable the selected ADC injected discontinuous mode */
   1618              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   1619            }
   1620          }
   1621          
   1622          /**
   1623            * @brief  Returns the ADC injected channel conversion result.
   1624            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1625            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1626            *   This parameter can be one of the following values:
   1627            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1628            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1629            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1630            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1631            * @retval The Data conversion value.
   1632            */
   1633          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1634          {
   1635            __IO uint32_t tmp = 0;
   1636            
   1637            /* Check the parameters */
   1638            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1639            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1640          
   1641            tmp = (uint32_t)ADCx;
   1642            tmp += ADC_InjectedChannel + JDR_OFFSET;
   1643            
   1644            /* Returns the selected injected channel conversion data value */
   1645            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   1646          }
   1647          
   1648          /**
   1649            * @}
   1650            */
   1651          
   1652          /** @defgroup ADC_Group8 Interrupts and flags management functions
   1653           *  @brief   Interrupts and flags management functions.
   1654           *
   1655          @verbatim   
   1656           ===============================================================================
   1657                      ##### Interrupts and flags management functions #####
   1658           ===============================================================================
   1659              [..] This section provides functions allowing to configure the ADC Interrupts 
   1660                   and get the status and clear flags and Interrupts pending bits.
   1661            
   1662              [..] The ADC provide 4 Interrupts sources and 9 Flags which can be divided into 
   1663                   3 groups:
   1664            *** Flags and Interrupts for ADC regular channels ***
   1665            =====================================================
   1666              [..]
   1667                  (+)Flags :
   1668                     (##) ADC_FLAG_OVR : Overrun detection when regular converted data are 
   1669                          lost.
   1670                     (##) ADC_FLAG_EOC : Regular channel end of conversion + to indicate 
   1671                          (depending on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() )
   1672                          the end of :
   1673                          (+++) a regular CHANNEL conversion.
   1674                          (+++) sequence of regular GROUP conversions.
   1675          
   1676          
   1677                     (##) ADC_FLAG_STRT: Regular channel start + to indicate when regular 
   1678                          CHANNEL conversion starts.
   1679                     (##) ADC_FLAG_RCNR: Regular channel not ready + to indicate if a new 
   1680                          regular conversion can be launched.
   1681                  (+)Interrupts :
   1682                     (##) ADC_IT_OVR : specifies the interrupt source for Overrun detection 
   1683                          event.
   1684                     (##) ADC_IT_EOC : specifies the interrupt source for Regular channel 
   1685                          end of conversion event.
   1686            
   1687            *** Flags and Interrupts for ADC Injected channels ***
   1688            ======================================================
   1689                  (+)Flags :
   1690                     (##) ADC_FLAG_JEOC : Injected channel end of conversion+ to indicate at 
   1691                          the end of injected GROUP conversion.
   1692                     (##) ADC_FLAG_JSTRT: Injected channel start +  to indicate hardware when 
   1693                          injected GROUP conversion starts.
   1694                     (##) ADC_FLAG_JCNR: Injected channel not ready + to indicate if a new 
   1695                          injected conversion can be launched.
   1696                  (+)Interrupts 
   1697                     (##) ADC_IT_JEOC : specifies the interrupt source for Injected channel 
   1698                          end of conversion event.
   1699            *** General Flags and Interrupts for the ADC ***
   1700            ================================================
   1701                  (+)Flags :
   1702                     (##) ADC_FLAG_AWD: Analog watchdog + to indicate if the converted voltage 
   1703                          crosses the programmed thresholds values.
   1704                     (##) ADC_FLAG_ADONS: ADC ON status + to indicate if the ADC is ready 
   1705                          to convert.
   1706                  (+)Interrupts :
   1707                     (##) ADC_IT_AWD : specifies the interrupt source for Analog watchdog 
   1708                          event.
   1709            
   1710              [..] The user should identify which mode will be used in his application to 
   1711                   manage the ADC controller events: Polling mode or Interrupt mode.
   1712            
   1713              [..] In the Polling Mode it is advised to use the following functions:
   1714                   (+) ADC_GetFlagStatus() : to check if flags events occur.
   1715                   (+) ADC_ClearFlag()     : to clear the flags events.
   1716            
   1717              [..] In the Interrupt Mode it is advised to use the following functions:
   1718                   (+) ADC_ITConfig()       : to enable or disable the interrupt source.
   1719                   (+) ADC_GetITStatus()    : to check if Interrupt occurs.
   1720                   (+) ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1721                       (corresponding Flag).
   1722          @endverbatim
   1723            * @{
   1724            */ 
   1725          
   1726          /**
   1727            * @brief  Enables or disables the specified ADC interrupts.
   1728            * @param  ADCx: where x can be 1 to select the ADC peripheral.
   1729            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled.
   1730            *   This parameter can be one of the following values:
   1731            *     @arg ADC_IT_EOC: End of conversion interrupt
   1732            *     @arg ADC_IT_AWD: Analog watchdog interrupt
   1733            *     @arg ADC_IT_JEOC: End of injected conversion interrupt
   1734            *     @arg ADC_IT_OVR: overrun interrupt
   1735            * @param  NewState: new state of the specified ADC interrupts.
   1736            *         This parameter can be: ENABLE or DISABLE.
   1737            * @retval None
   1738            */
   1739          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1740          {
   1741            uint32_t itmask = 0;
   1742          
   1743            /* Check the parameters */
   1744            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1745            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1746            assert_param(IS_ADC_IT(ADC_IT)); 
   1747          
   1748            /* Get the ADC IT index */
   1749            itmask = (uint8_t)ADC_IT;
   1750            itmask = (uint32_t)0x01 << itmask;    
   1751          
   1752            if (NewState != DISABLE)
   1753            {
   1754              /* Enable the selected ADC interrupts */
   1755              ADCx->CR1 |= itmask;
   1756            }
   1757            else
   1758            {
   1759              /* Disable the selected ADC interrupts */
   1760              ADCx->CR1 &= (~(uint32_t)itmask);
   1761            }
   1762          }
   1763          
   1764          /**
   1765            * @brief  Checks whether the specified ADC flag is set or not.
   1766            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1767            * @param  ADC_FLAG: specifies the flag to check.
   1768            *   This parameter can be one of the following values:
   1769            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1770            *     @arg ADC_FLAG_EOC: End of conversion flag
   1771            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1772            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1773            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1774            *     @arg ADC_FLAG_OVR: Overrun flag
   1775            *     @arg ADC_FLAG_ADONS: ADC ON status
   1776            *     @arg ADC_FLAG_RCNR: Regular channel not ready
   1777            *     @arg ADC_FLAG_JCNR: Injected channel not ready
   1778            * @retval The new state of ADC_FLAG (SET or RESET).
   1779            */
   1780          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
   1781          {
   1782            FlagStatus bitstatus = RESET;
   1783          
   1784            /* Check the parameters */
   1785            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1786            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1787          
   1788            /* Check the status of the specified ADC flag */
   1789            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   1790            {
   1791              /* ADC_FLAG is set */
   1792              bitstatus = SET;
   1793            }
   1794            else
   1795            {
   1796              /* ADC_FLAG is reset */
   1797              bitstatus = RESET;
   1798            }
   1799            /* Return the ADC_FLAG status */
   1800            return  bitstatus;
   1801          }
   1802          
   1803          /**
   1804            * @brief  Clears the ADCx's pending flags.
   1805            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1806            * @param  ADC_FLAG: specifies the flag to clear.
   1807            *   This parameter can be any combination of the following values:
   1808            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1809            *     @arg ADC_FLAG_EOC: End of conversion flag
   1810            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1811            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1812            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1813            *     @arg ADC_FLAG_OVR: overrun flag
   1814            * @retval None
   1815            */
   1816          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
   1817          {
   1818            /* Check the parameters */
   1819            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1820            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1821          
   1822            /* Clear the selected ADC flags */
   1823            ADCx->SR = ~(uint32_t)ADC_FLAG;
   1824          }
   1825          
   1826          /**
   1827            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1828            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1829            * @param  ADC_IT: specifies the ADC interrupt source to check.
   1830            *   This parameter can be one of the following values:
   1831            *     @arg ADC_IT_EOC: End of conversion interrupt
   1832            *     @arg ADC_IT_AWD: Analog watchdog interrupt
   1833            *     @arg ADC_IT_JEOC: End of injected conversion interrupt
   1834            *     @arg ADC_IT_OVR: Overrun interrupt
   1835            * @retval The new state of ADC_IT (SET or RESET).
   1836            */
   1837          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1838          {
   1839            ITStatus bitstatus = RESET;
   1840            uint32_t itmask = 0, enablestatus = 0;
   1841          
   1842            /* Check the parameters */
   1843            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1844            assert_param(IS_ADC_IT(ADC_IT));
   1845          
   1846            /* Get the ADC IT index */
   1847            itmask = (uint32_t)((uint32_t)ADC_IT >> 8);
   1848          
   1849            /* Get the ADC_IT enable bit status */
   1850            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)); 
   1851          
   1852            /* Check the status of the specified ADC interrupt */
   1853            if (((uint32_t)(ADCx->SR & (uint32_t)itmask) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
   1854            {                                                         
   1855              /* ADC_IT is set */
   1856              bitstatus = SET;
   1857            }
   1858            else
   1859            {
   1860              /* ADC_IT is reset */
   1861              bitstatus = RESET;
   1862            }
   1863            /* Return the ADC_IT status */
   1864            return  bitstatus;
   1865          }
   1866          
   1867          /**
   1868            * @brief  Clears the ADCx's interrupt pending bits.
   1869            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1870            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1871            *   This parameter can be one of the following values:
   1872            *     @arg ADC_IT_EOC: End of conversion interrupt
   1873            *     @arg ADC_IT_AWD: Analog watchdog interrupt
   1874            *     @arg ADC_IT_JEOC: End of injected conversion interrupt
   1875            *     @arg ADC_IT_OVR: Overrun interrupt
   1876            * @retval None
   1877            */
   1878          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1879          {
   1880            uint8_t itmask = 0;
   1881          
   1882            /* Check the parameters */
   1883            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1884            assert_param(IS_ADC_IT(ADC_IT)); 
   1885          
   1886            /* Get the ADC IT index */
   1887            itmask = (uint8_t)(ADC_IT >> 8);
   1888          
   1889            /* Clear the selected ADC interrupt pending bits */
   1890            ADCx->SR = ~(uint32_t)itmask;
   1891          }
   1892          
   1893          /**
   1894            * @}
   1895            */
   1896          
   1897          /**
   1898            * @}
   1899            */ 
   1900          
   1901          /**
   1902            * @}
   1903            */ 
   1904          
   1905          /**
   1906            * @}
   1907            */ 
   1908          
   1909          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_AnalogWatchdogCmd
       0   ADC_AnalogWatchdogSingleChannelConfig
       0   ADC_AnalogWatchdogThresholdsConfig
       0   ADC_AutoInjectedConvCmd
       0   ADC_BankSelection
       0   ADC_ClearFlag
       0   ADC_ClearITPendingBit
       0   ADC_Cmd
       0   ADC_CommonInit
       0   ADC_CommonStructInit
       0   ADC_ContinuousModeCmd
       0   ADC_DMACmd
       0   ADC_DMARequestAfterLastTransferCmd
       8   ADC_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   ADC_DelaySelectionConfig
       0   ADC_DiscModeChannelCountConfig
       0   ADC_DiscModeCmd
       0   ADC_EOCOnEachRegularChannelCmd
       0   ADC_ExternalTrigInjectedConvConfig
       0   ADC_ExternalTrigInjectedConvEdgeConfig
       0   ADC_GetConversionValue
       0   ADC_GetFlagStatus
       4   ADC_GetITStatus
       4   ADC_GetInjectedConversionValue
       0   ADC_GetSoftwareStartConvStatus
       0   ADC_GetSoftwareStartInjectedConvCmdStatus
       0   ADC_ITConfig
       8   ADC_Init
      16   ADC_InjectedChannelConfig
       0   ADC_InjectedDiscModeCmd
       0   ADC_InjectedSequencerLengthConfig
       0   ADC_PowerDownCmd
      16   ADC_RegularChannelConfig
       4   ADC_SetInjectedOffset
       0   ADC_SoftwareStartConv
       0   ADC_SoftwareStartInjectedConv
       0   ADC_StructInit
       0   ADC_TempSensorVrefintCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      14  ADC_AnalogWatchdogCmd
      16  ADC_AnalogWatchdogSingleChannelConfig
      10  ADC_AnalogWatchdogThresholdsConfig
      26  ADC_AutoInjectedConvCmd
      26  ADC_BankSelection
       8  ADC_ClearFlag
      14  ADC_ClearITPendingBit
      26  ADC_Cmd
      20  ADC_CommonInit
       6  ADC_CommonStructInit
      26  ADC_ContinuousModeCmd
      26  ADC_DMACmd
      26  ADC_DMARequestAfterLastTransferCmd
      30  ADC_DeInit
      16  ADC_DelaySelectionConfig
      22  ADC_DiscModeChannelCountConfig
      26  ADC_DiscModeCmd
      26  ADC_EOCOnEachRegularChannelCmd
      14  ADC_ExternalTrigInjectedConvConfig
      14  ADC_ExternalTrigInjectedConvEdgeConfig
       6  ADC_GetConversionValue
      22  ADC_GetFlagStatus
      46  ADC_GetITStatus
      28  ADC_GetInjectedConversionValue
      20  ADC_GetSoftwareStartConvStatus
      20  ADC_GetSoftwareStartInjectedConvCmdStatus
      34  ADC_ITConfig
      74  ADC_Init
     216  ADC_InjectedChannelConfig
      26  ADC_InjectedDiscModeCmd
      22  ADC_InjectedSequencerLengthConfig
      24  ADC_PowerDownCmd
     364  ADC_RegularChannelConfig
      26  ADC_SetInjectedOffset
      10  ADC_SoftwareStartConv
      10  ADC_SoftwareStartInjectedConv
      32  ADC_StructInit
      34  ADC_TempSensorVrefintCmd

 
 1 426 bytes in section .text
 
 1 426 bytes of CODE memory

Errors: none
Warnings: none
