###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        24/Nov/2014  11:34:28
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_sdio.c
#    Command line =  
#        "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_sdio.c"
#        -D USE_STDPERIPH_DRIVER -D STM32L1XX_XL -lcN "D:\Mes
#        Documents\ST32\Toolbox_TP1\Debug\List\" -o "D:\Mes
#        Documents\ST32\Toolbox_TP1\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\"
#        -I "D:\Mes Documents\ST32\Toolbox_TP1\Libraries\CMSIS\Include\" -I
#        "D:\Mes Documents\ST32\Toolbox_TP1\" -I "D:\Mes
#        Documents\ST32\Toolbox_TP1\Libraries\stm32l1xx_nucleo\" -Ol
#    List file    =  
#        D:\Mes Documents\ST32\Toolbox_TP1\Debug\List\stm32l1xx_sdio.lst
#    Object file  =  
#        D:\Mes Documents\ST32\Toolbox_TP1\Debug\Obj\stm32l1xx_sdio.o
#
###############################################################################

D:\Mes Documents\ST32\Toolbox_TP1\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_sdio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_sdio.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    31-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the SDIO peripheral:
      9            *           + Initialization 
     10            *           + Interrupts and flags management
     11            *
     12            *  @verbatim
     13            ==============================================================================
     14                                   ##### How to use this driver #####
     15            ==============================================================================
     16              [..]
     17              (#) The SDIO clock (SDIOCLK = 48 MHz) is coming from a specific output of PLL
     18                 (PLLVCO) througth a fixed divider by 2.
     19                 Before to start working with SDIO peripheral make sure that the PLLVCO is 
     20                 well configured to 96MHz. 
     21                 The SDIO peripheral uses two clock signals: 
     22                 (++) SDIO adapter clock (SDIOCLK = 48 MHz).
     23                 (++) APB2 bus clock (PCLK2).
     24                      PCLK2 and SDIO_CK clock frequencies must respect the following 
     25                      condition: Frequenc(PCLK2) >= (3 / 8 x Frequency(SDIO_CK)).
     26              (#) Enable peripheral clock using 
     27                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SDIO, ENABLE). 
     28              (#) According to the SDIO mode, enable the GPIO clocks using
     29                  RCC_AHBPeriphClockCmd() function.
     30                  The I/O can be one of the following configurations: 
     31                  (++) 1-bit data length: SDIO_CMD, SDIO_CK and D0. 
     32                  (++) 4-bit data length: SDIO_CMD, SDIO_CK and D[3:0]. 
     33                  (++) 8-bit data length: SDIO_CMD, SDIO_CK and D[7:0].
     34          
     35              (#) Peripheral's alternate function:  
     36                  (++) Connect the pin to the desired peripherals' Alternate  
     37                       Function (AF) using GPIO_PinAFConfig() function.
     38                  (++) Configure the desired pin in alternate function by: 
     39                       GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF.
     40                  (++) Select the type, pull-up/pull-down and output speed via  
     41                       GPIO_PuPd, GPIO_OType and GPIO_Speed members.
     42                  (++) Call GPIO_Init() function.
     43          
     44              (#) Program the Clock Edge, Clock Bypass, Clock Power Save, Bus Wide,  
     45                  hardware, flow control and the Clock Divider using the SDIO_Init() 
     46                  function. 
     47              (#) Enable the Power ON State using the SDIO_SetPowerState(SDIO_PowerState_ON)  
     48                  function.           
     49              (#) Enable the clock using the SDIO_ClockCmd() function. 
     50              (#) Enable the NVIC and the corresponding interrupt using the function  
     51                  SDIO_ITConfig() if you need to use interrupt mode.  
     52              (#) When using the DMA mode
     53                  (++) Configure the DMA using DMA_Init() function.
     54                  (++) Active the needed channel Request using SDIO_DMACmd() function.
     55              (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode.
     56              (#) To control the CPSM (Command Path State Machine) and send commands to the
     57                  card use the SDIO_SendCommand(), SDIO_GetCommandResponse() and 
     58                  SDIO_GetResponse() functions. First, user has to fill the command 
     59                  structure (pointer to SDIO_CmdInitTypeDef) according to the selected 
     60                  command to be sent. The parameters that should be filled are: 
     61                  (++) Command Argument.
     62                  (++) Command Index.
     63                  (++) Command Response type.
     64                  (++) Command Wait.
     65                  (++) CPSM Status (Enable or Disable).
     66                  To check if the command is well received, read the SDIO_CMDRESP register 
     67                  using the SDIO_GetCommandResponse(). The SDIO responses registers 
     68                  (SDIO_RESP1 to SDIO_RESP2), use the SDIO_GetResponse() function. 
     69              (#) To control the DPSM (Data Path State Machine) and send/receive  
     70                  data to/from the card use the SDIO_DataConfig(), SDIO_GetDataCounter(),
     71                  SDIO_ReadData(), SDIO_WriteData() and SDIO_GetFIFOCount() functions.
     72          
     73              *** Read Operations *** 
     74              ----------------------- 
     75                [..]
     76                (#) First, user has to fill the data structure (pointer to 
     77                    SDIO_DataInitTypeDef) according to the selected data type to be received. 
     78                    The parameters that should be filled are:
     79                    (++) Data TimeOut.
     80                    (++) Data Length.
     81                    (++) Data Block size.
     82                    (++) Data Transfer direction: should be from card (To SDIO).
     83                    (++) Data Transfer mode.
     84                    (++) DPSM Status (Enable or Disable).
     85                (#) Configure the SDIO resources to receive the data from the card 
     86                    according to selected transfer mode (Refer to Step 8, 9 and 10).
     87                (#) Send the selected Read command (refer to step 11).
     88                (#) Use the SDIO flags/interrupts to check the transfer status.
     89           
     90            *** Write Operations *** 
     91            ------------------------ 
     92              [..]
     93              (#) First, user has to fill the data structure (pointer to
     94                  SDIO_DataInitTypeDef) according to the selected data type to be received. 
     95                  The parameters that should be filled are: 
     96                  (++) Data TimeOut.
     97                  (++) Data Length.
     98                  (++) Data Block size.
     99                  (++) Data Transfer direction:  should be to card (To CARD).
    100                  (++) Data Transfer mode.
    101                  (++) DPSM Status (Enable or Disable).
    102              (#) Configure the SDIO resources to send the data to the card 
    103                  according to selected transfer mode (Refer to Step 8, 9 and 10).
    104              (#) Send the selected Write command (refer to step 11).
    105              (#) Use the SDIO flags/interrupts to check the transfer status.
    106          
    107            @endverbatim
    108            *
    109            ******************************************************************************
    110            * @attention
    111            *
    112            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
    113            *
    114            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    115            * You may not use this file except in compliance with the License.
    116            * You may obtain a copy of the License at:
    117            *
    118            *        http://www.st.com/software_license_agreement_liberty_v2
    119            *
    120            * Unless required by applicable law or agreed to in writing, software 
    121            * distributed under the License is distributed on an "AS IS" BASIS, 
    122            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    123            * See the License for the specific language governing permissions and
    124            * limitations under the License.
    125            *
    126            ******************************************************************************
    127            */ 
    128          
    129          /* Includes ------------------------------------------------------------------*/
    130          #include "stm32l1xx_sdio.h"
    131          #include "stm32l1xx_rcc.h"
    132          
    133          /** @addtogroup STM32L1xx_StdPeriph_Driver
    134            * @{
    135            */
    136          
    137          /** @defgroup SDIO 
    138            * @brief SDIO driver modules
    139            * @{
    140            */ 
    141          
    142          /* Private typedef -----------------------------------------------------------*/
    143          /* Private define ------------------------------------------------------------*/ 
    144          
    145          /* ------------ SDIO registers bit address in the alias region ----------- */
    146          #define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
    147          
    148          /* --- CLKCR Register ---*/
    149          
    150          /* Alias word address of CLKEN bit */
    151          #define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
    152          #define CLKEN_BitNumber           0x08
    153          #define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
    154          
    155          /* --- CMD Register ---*/
    156          
    157          /* Alias word address of SDIOSUSPEND bit */
    158          #define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
    159          #define SDIOSUSPEND_BitNumber     0x0B
    160          #define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
    161          
    162          /* Alias word address of ENCMDCOMPL bit */
    163          #define ENCMDCOMPL_BitNumber      0x0C
    164          #define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
    165          
    166          /* Alias word address of NIEN bit */
    167          #define NIEN_BitNumber            0x0D
    168          #define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
    169          
    170          /* Alias word address of ATACMD bit */
    171          #define ATACMD_BitNumber          0x0E
    172          #define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
    173          
    174          /* --- DCTRL Register ---*/
    175          
    176          /* Alias word address of DMAEN bit */
    177          #define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
    178          #define DMAEN_BitNumber           0x03
    179          #define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
    180          
    181          /* Alias word address of RWSTART bit */
    182          #define RWSTART_BitNumber         0x08
    183          #define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
    184          
    185          /* Alias word address of RWSTOP bit */
    186          #define RWSTOP_BitNumber          0x09
    187          #define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
    188          
    189          /* Alias word address of RWMOD bit */
    190          #define RWMOD_BitNumber           0x0A
    191          #define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
    192          
    193          /* Alias word address of SDIOEN bit */
    194          #define SDIOEN_BitNumber          0x0B
    195          #define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
    196          
    197          /* ---------------------- SDIO registers bit mask ------------------------ */
    198          
    199          /* --- CLKCR Register ---*/
    200          
    201          /* CLKCR register clear mask */
    202          #define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100) 
    203          
    204          /* --- PWRCTRL Register ---*/
    205          
    206          /* SDIO PWRCTRL Mask */
    207          #define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)
    208          
    209          /* --- DCTRL Register ---*/
    210          
    211          /* SDIO DCTRL Clear Mask */
    212          #define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)
    213          
    214          /* --- CMD Register ---*/
    215          
    216          /* CMD Register clear mask */
    217          #define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)
    218          
    219          /* SDIO RESP Registers Address */
    220          #define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))
    221          
    222          /* Private macro -------------------------------------------------------------*/
    223          /* Private variables ---------------------------------------------------------*/
    224          /* Private function prototypes -----------------------------------------------*/
    225          /* Private functions ---------------------------------------------------------*/
    226          
    227          /** @defgroup SDIO_Private_Functions
    228            * @{
    229            */
    230          
    231          /** @defgroup SDIO_Group1 Initialization and Configuration functions
    232           *  @brief   Initialization and Configuration functions 
    233           *
    234           @verbatim
    235            ==============================================================================
    236                        ##### Initialization and Configuration functions #####
    237            ==============================================================================
    238          
    239          @endverbatim
    240            * @{
    241            */
    242          
    243          /**
    244            * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
    245            * @param  None
    246            * @retval None
    247            */
    248          void SDIO_DeInit(void)
    249          {
    250            RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
    251            RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);  
    252          }
    253          
    254          /**
    255            * @brief  Initializes the SDIO peripheral according to the specified 
    256            *   parameters in the SDIO_InitStruct.
    257            * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
    258            *   that contains the configuration information for the SDIO peripheral.
    259            * @retval None
    260            */
    261          void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
    262          {
    263            uint32_t tmpreg = 0;
    264              
    265            /* Check the parameters */
    266            assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
    267            assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
    268            assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
    269            assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
    270            assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
    271             
    272          /*---------------------------- SDIO CLKCR Configuration ------------------------*/  
    273            /* Get the SDIO CLKCR value */
    274            tmpreg = SDIO->CLKCR;
    275            
    276            /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
    277            tmpreg &= CLKCR_CLEAR_MASK;
    278            
    279            /* Set CLKDIV bits according to SDIO_ClockDiv value */
    280            /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
    281            /* Set BYPASS bit according to SDIO_ClockBypass value */
    282            /* Set WIDBUS bits according to SDIO_BusWide value */
    283            /* Set NEGEDGE bits according to SDIO_ClockEdge value */
    284            /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
    285            tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
    286                       SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
    287                       SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
    288            
    289            /* Write to SDIO CLKCR */
    290            SDIO->CLKCR = tmpreg;
    291          }
    292          
    293          /**
    294            * @brief  Fills each SDIO_InitStruct member with its default value.
    295            * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
    296            *   will be initialized.
    297            * @retval None
    298            */
    299          void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
    300          {
    301            /* SDIO_InitStruct members default value */
    302            SDIO_InitStruct->SDIO_ClockDiv = 0x00;
    303            SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
    304            SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
    305            SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
    306            SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
    307            SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
    308          }
    309          
    310          /**
    311            * @brief  Enables or disables the SDIO Clock.
    312            * @param  NewState: new state of the SDIO Clock. This parameter can be: ENABLE or DISABLE.
    313            * @retval None
    314            */
    315          void SDIO_ClockCmd(FunctionalState NewState)
    316          {
    317            /* Check the parameters */
    318            assert_param(IS_FUNCTIONAL_STATE(NewState));
    319            
    320            *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
    321          }
    322          
    323          /**
    324            * @brief  Sets the power status of the controller.
    325            * @param  SDIO_PowerState: new state of the Power state. 
    326            *   This parameter can be one of the following values:
    327            *     @arg SDIO_PowerState_OFF: SDIO Power OFF.
    328            *     @arg SDIO_PowerState_ON: SDIO Power ON.
    329            * @retval None
    330            */
    331          void SDIO_SetPowerState(uint32_t SDIO_PowerState)
    332          {
    333            /* Check the parameters */
    334            assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
    335          
    336            SDIO->POWER = SDIO_PowerState;
    337          }
    338          
    339          /**
    340            * @brief  Gets the power status of the controller.
    341            * @param  None
    342            * @retval Power status of the controller. The returned value can
    343            *   be one of the following:
    344            * - 0x00: Power OFF
    345            * - 0x02: Power UP
    346            * - 0x03: Power ON 
    347            */
    348          uint32_t SDIO_GetPowerState(void)
    349          {
    350            return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
    351          }
    352          
    353          /**
    354            * @}
    355            */
    356          
    357          /** @defgroup SDIO_Group2 DMA transfers management functions
    358           *  @brief   DMA transfers management functions
    359           *
    360           @verbatim
    361            ==============================================================================
    362                            ##### DMA transfers management functions #####
    363            ==============================================================================
    364              [..] This section provide functions allowing to program SDIO DMA transfer.
    365          
    366          @endverbatim
    367            * @{
    368            */
    369          
    370          /**
    371            * @brief  Enables or disables the SDIO DMA request.
    372            * @param  NewState: new state of the selected SDIO DMA request.
    373            *   This parameter can be: ENABLE or DISABLE.
    374            * @retval None
    375            */
    376          void SDIO_DMACmd(FunctionalState NewState)
    377          {
    378            /* Check the parameters */
    379            assert_param(IS_FUNCTIONAL_STATE(NewState));
    380            
    381            *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
    382          }
    383          
    384          /**
    385            * @}
    386            */
    387          
    388          /** @defgroup SDIO_Group3 Command path state machine (CPSM) management functions
    389           *  @brief   Command path state machine (CPSM) management functions 
    390           *
    391           @verbatim
    392            ==============================================================================
    393                 ##### Command path state machine (CPSM) management functions #####
    394            ==============================================================================
    395            [..] This section provide functions allowing to program and read the Command 
    396                 path state machine (CPSM).
    397          
    398          @endverbatim
    399            * @{
    400            */
    401          
    402          /**
    403            * @brief  Initializes the SDIO Command according to the specified 
    404            *   parameters in the SDIO_CmdInitStruct and send the command.
    405            * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
    406            *   structure that contains the configuration information for the SDIO command.
    407            * @retval None
    408            */
    409          void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
    410          {
    411            uint32_t tmpreg = 0;
    412            
    413            /* Check the parameters */
    414            assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
    415            assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
    416            assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
    417            assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
    418            
    419          /*---------------------------- SDIO ARG Configuration ------------------------*/
    420            /* Set the SDIO Argument value */
    421            SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
    422            
    423          /*---------------------------- SDIO CMD Configuration ------------------------*/  
    424            /* Get the SDIO CMD value */
    425            tmpreg = SDIO->CMD;
    426            /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
    427            tmpreg &= CMD_CLEAR_MASK;
    428            /* Set CMDINDEX bits according to SDIO_CmdIndex value */
    429            /* Set WAITRESP bits according to SDIO_Response value */
    430            /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
    431            /* Set CPSMEN bits according to SDIO_CPSM value */
    432            tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
    433                     | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
    434            
    435            /* Write to SDIO CMD */
    436            SDIO->CMD = tmpreg;
    437          }
    438          
    439          /**
    440            * @brief  Fills each SDIO_CmdInitStruct member with its default value.
    441            * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
    442            *   structure which will be initialized.
    443            * @retval None
    444            */
    445          void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
    446          {
    447            /* SDIO_CmdInitStruct members default value */
    448            SDIO_CmdInitStruct->SDIO_Argument = 0x00;
    449            SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
    450            SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
    451            SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
    452            SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
    453          }
    454          
    455          /**
    456            * @brief  Returns command index of last command for which response received.
    457            * @param  None
    458            * @retval Returns the command index of the last command response received.
    459            */
    460          uint8_t SDIO_GetCommandResponse(void)
    461          {
    462            return (uint8_t)(SDIO->RESPCMD);
    463          }
    464          
    465          /**
    466            * @brief  Returns response received from the card for the last command.
    467            * @param  SDIO_RESP: Specifies the SDIO response register. 
    468            *   This parameter can be one of the following values:
    469            *     @arg SDIO_RESP1: Response Register 1.
    470            *     @arg SDIO_RESP2: Response Register 2.
    471            *     @arg SDIO_RESP3: Response Register 3.
    472            *     @arg SDIO_RESP4: Response Register 4.
    473            * @retval The Corresponding response register value.
    474            */
    475          uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
    476          {
    477            __IO uint32_t tmp = 0;
    478          
    479            /* Check the parameters */
    480            assert_param(IS_SDIO_RESP(SDIO_RESP));
    481          
    482            tmp = SDIO_RESP_ADDR + SDIO_RESP;
    483            
    484            return (*(__IO uint32_t *) tmp); 
    485          }
    486          
    487          /**
    488            * @}
    489            */
    490          
    491          /** @defgroup SDIO_Group4 Data path state machine (DPSM) management functions
    492           *  @brief   Data path state machine (DPSM) management functions
    493           *
    494           @verbatim
    495            ==============================================================================
    496                  ##### Data path state machine (DPSM) management functions #####
    497            ==============================================================================
    498            [..] This section provide functions allowing to program and read the Data path 
    499                 state machine (DPSM).
    500          
    501          @endverbatim
    502            * @{
    503            */
    504          
    505          /**
    506            * @brief  Initializes the SDIO data path according to the specified 
    507            *   parameters in the SDIO_DataInitStruct.
    508            * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure that
    509            *   contains the configuration information for the SDIO command.
    510            * @retval None
    511            */
    512          void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
    513          {
    514            uint32_t tmpreg = 0;
    515            
    516            /* Check the parameters */
    517            assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
    518            assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
    519            assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
    520            assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
    521            assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
    522          
    523          /*---------------------------- SDIO DTIMER Configuration ---------------------*/
    524            /* Set the SDIO Data TimeOut value */
    525            SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
    526          
    527          /*---------------------------- SDIO DLEN Configuration -----------------------*/
    528            /* Set the SDIO DataLength value */
    529            SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
    530          
    531          /*---------------------------- SDIO DCTRL Configuration ----------------------*/  
    532            /* Get the SDIO DCTRL value */
    533            tmpreg = SDIO->DCTRL;
    534            /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
    535            tmpreg &= DCTRL_CLEAR_MASK;
    536            /* Set DEN bit according to SDIO_DPSM value */
    537            /* Set DTMODE bit according to SDIO_TransferMode value */
    538            /* Set DTDIR bit according to SDIO_TransferDir value */
    539            /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
    540            tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
    541                     | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
    542          
    543            /* Write to SDIO DCTRL */
    544            SDIO->DCTRL = tmpreg;
    545          }
    546          
    547          /**
    548            * @brief  Fills each SDIO_DataInitStruct member with its default value.
    549            * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure which
    550            *   will be initialized.
    551            * @retval None
    552            */
    553          void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
    554          {
    555            /* SDIO_DataInitStruct members default value */
    556            SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
    557            SDIO_DataInitStruct->SDIO_DataLength = 0x00;
    558            SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
    559            SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
    560            SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
    561            SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
    562          }
    563          
    564          /**
    565            * @brief  Returns number of remaining data bytes to be transferred.
    566            * @param  None
    567            * @retval Number of remaining data bytes to be transferred
    568            */
    569          uint32_t SDIO_GetDataCounter(void)
    570          { 
    571            return SDIO->DCOUNT;
    572          }
    573          
    574          /**
    575            * @brief  Read one data word from Rx FIFO.
    576            * @param  None
    577            * @retval Data received
    578            */
    579          uint32_t SDIO_ReadData(void)
    580          { 
    581            return SDIO->FIFO;
    582          }
    583          
    584          /**
    585            * @brief  Write one data word to Tx FIFO.
    586            * @param  Data: 32-bit data word to write.
    587            * @retval None
    588            */
    589          void SDIO_WriteData(uint32_t Data)
    590          { 
    591            SDIO->FIFO = Data;
    592          }
    593          
    594          /**
    595            * @brief  Returns the number of words left to be written to or read from FIFO.	
    596            * @param  None
    597            * @retval Remaining number of words.
    598            */
    599          uint32_t SDIO_GetFIFOCount(void)
    600          { 
    601            return SDIO->FIFOCNT;
    602          }
    603          
    604          /**
    605            * @}
    606            */
    607          
    608          /** @defgroup SDIO_Group5 SDIO IO Cards mode management functions
    609           *  @brief   SDIO IO Cards mode management functions
    610           *
    611           @verbatim
    612            ==============================================================================
    613                        ##### SDIO IO Cards mode management functions #####
    614            ==============================================================================
    615            [..] This section provide functions allowing to program and read the SDIO IO 
    616                 Cards.
    617          
    618          @endverbatim
    619            * @{
    620            */
    621          
    622          /**
    623            * @brief  Starts the SD I/O Read Wait operation.	
    624            * @param  NewState: new state of the Start SDIO Read Wait operation. 
    625            *   This parameter can be: ENABLE or DISABLE.
    626            * @retval None
    627            */
    628          void SDIO_StartSDIOReadWait(FunctionalState NewState)
    629          { 
    630            /* Check the parameters */
    631            assert_param(IS_FUNCTIONAL_STATE(NewState));
    632            
    633            *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
    634          }
    635          
    636          /**
    637            * @brief  Stops the SD I/O Read Wait operation.	
    638            * @param  NewState: new state of the Stop SDIO Read Wait operation. 
    639            *   This parameter can be: ENABLE or DISABLE.
    640            * @retval None
    641            */
    642          void SDIO_StopSDIOReadWait(FunctionalState NewState)
    643          { 
    644            /* Check the parameters */
    645            assert_param(IS_FUNCTIONAL_STATE(NewState));
    646            
    647            *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
    648          }
    649          
    650          /**
    651            * @brief  Sets one of the two options of inserting read wait interval.
    652            * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
    653            *   This parametre can be:
    654            *     @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK.
    655            *     @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2.
    656            * @retval None
    657            */
    658          void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
    659          {
    660            /* Check the parameters */
    661            assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
    662            
    663            *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
    664          }
    665          
    666          /**
    667            * @brief  Enables or disables the SD I/O Mode Operation.
    668            * @param  NewState: new state of SDIO specific operation. 
    669            *   This parameter can be: ENABLE or DISABLE.
    670            * @retval None
    671            */
    672          void SDIO_SetSDIOOperation(FunctionalState NewState)
    673          { 
    674            /* Check the parameters */
    675            assert_param(IS_FUNCTIONAL_STATE(NewState));
    676            
    677            *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
    678          }
    679          
    680          /**
    681            * @brief  Enables or disables the SD I/O Mode suspend command sending.
    682            * @param  NewState: new state of the SD I/O Mode suspend command.
    683            *   This parameter can be: ENABLE or DISABLE.
    684            * @retval None
    685            */
    686          void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
    687          { 
    688            /* Check the parameters */
    689            assert_param(IS_FUNCTIONAL_STATE(NewState));
    690            
    691            *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
    692          }
    693          
    694          /**
    695            * @}
    696            */
    697          
    698          /** @defgroup SDIO_Group6 CE-ATA mode management functions
    699           *  @brief   CE-ATA mode management functions
    700           *
    701           @verbatim
    702            ==============================================================================
    703                              ##### CE-ATA mode management functions #####
    704            ==============================================================================
    705            [..] This section provide functions allowing to program and read the CE-ATA 
    706                 card.
    707          
    708          @endverbatim
    709            * @{
    710            */
    711          
    712          /**
    713            * @brief  Enables or disables the command completion signal.
    714            * @param  NewState: new state of command completion signal. 
    715            *   This parameter can be: ENABLE or DISABLE.
    716            * @retval None
    717            */
    718          void SDIO_CommandCompletionCmd(FunctionalState NewState)
    719          { 
    720            /* Check the parameters */
    721            assert_param(IS_FUNCTIONAL_STATE(NewState));
    722            
    723            *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
    724          }
    725          
    726          /**
    727            * @brief  Enables or disables the CE-ATA interrupt.
    728            * @param  NewState: new state of CE-ATA interrupt. This parameter can be: ENABLE or DISABLE.
    729            * @retval None
    730            */
    731          void SDIO_CEATAITCmd(FunctionalState NewState)
    732          { 
    733            /* Check the parameters */
    734            assert_param(IS_FUNCTIONAL_STATE(NewState));
    735            
    736            *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
    737          }
    738          
    739          /**
    740            * @brief  Sends CE-ATA command (CMD61).
    741            * @param  NewState: new state of CE-ATA command. This parameter can be: ENABLE or DISABLE.
    742            * @retval None
    743            */
    744          void SDIO_SendCEATACmd(FunctionalState NewState)
    745          { 
    746            /* Check the parameters */
    747            assert_param(IS_FUNCTIONAL_STATE(NewState));
    748            
    749            *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
    750          }
    751          
    752          /**
    753            * @}
    754            */
    755          
    756          /** @defgroup SDIO_Group7 Interrupts and flags management functions
    757           *  @brief   Interrupts and flags management functions  
    758          
    759          
    760           @verbatim
    761            ==============================================================================
    762                        ##### Interrupts and flags management functions #####
    763            ==============================================================================
    764          
    765           @endverbatim
    766            * @{
    767            */
    768          
    769          /**
    770            * @brief  Enables or disables the SDIO interrupts.
    771            * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
    772            *   This parameter can be one or a combination of the following values:
    773            *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt.
    774            *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt.
    775            *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt.
    776            *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt.
    777            *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt.
    778            *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt.
    779            *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt.
    780            *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt.
    781            *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt.
    782            *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    783            *                            bus mode interrupt.
    784            *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt.
    785            *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt.
    786            *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt.
    787            *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt.
    788            *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt.
    789            *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt.
    790            *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt.
    791            *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt.
    792            *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt.
    793            *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt.
    794            *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt.
    795            *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt.
    796            *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt.
    797            *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt.
    798            * @param  NewState: new state of the specified SDIO interrupts.
    799            *   This parameter can be: ENABLE or DISABLE.
    800            * @retval None 
    801            */
    802          void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
    803          {
    804            /* Check the parameters */
    805            assert_param(IS_SDIO_IT(SDIO_IT));
    806            assert_param(IS_FUNCTIONAL_STATE(NewState));
    807            
    808            if (NewState != DISABLE)
    809            {
    810              /* Enable the SDIO interrupts */
    811              SDIO->MASK |= SDIO_IT;
    812            }
    813            else
    814            {
    815              /* Disable the SDIO interrupts */
    816              SDIO->MASK &= ~SDIO_IT;
    817            } 
    818          }
    819          
    820          /**
    821            * @brief  Checks whether the specified SDIO flag is set or not.
    822            * @param  SDIO_FLAG: specifies the flag to check. 
    823            *   This parameter can be one of the following values:
    824            *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed).
    825            *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed).
    826            *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout.
    827            *     @arg SDIO_FLAG_DTIMEOUT: Data timeout.
    828            *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error.
    829            *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error.
    830            *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed).
    831            *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required).
    832            *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero).
    833            *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide 
    834            *                              bus mode.
    835            *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed).
    836            *     @arg SDIO_FLAG_CMDACT:   Command transfer in progress.
    837            *     @arg SDIO_FLAG_TXACT:    Data transmit in progress.
    838            *     @arg SDIO_FLAG_RXACT:    Data receive in progress.
    839            *     @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty.
    840            *     @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full.
    841            *     @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full.
    842            *     @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full.
    843            *     @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty.
    844            *     @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty.
    845            *     @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO.
    846            *     @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO.
    847            *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received.
    848            *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61.
    849            * @retval The new state of SDIO_FLAG (SET or RESET).
    850            */
    851          FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
    852          { 
    853            FlagStatus bitstatus = RESET;
    854            
    855            /* Check the parameters */
    856            assert_param(IS_SDIO_FLAG(SDIO_FLAG));
    857            
    858            if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
    859            {
    860              bitstatus = SET;
    861            }
    862            else
    863            {
    864              bitstatus = RESET;
    865            }
    866            return bitstatus;
    867          }
    868          
    869          /**
    870            * @brief  Clears the SDIO's pending flags.
    871            * @param  SDIO_FLAG: specifies the flag to clear.  
    872            *   This parameter can be one or a combination of the following values:
    873            *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed).
    874            *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed).
    875            *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout.
    876            *     @arg SDIO_FLAG_DTIMEOUT: Data timeout.
    877            *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error.
    878            *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error.
    879            *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed).
    880            *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required).
    881            *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero).
    882            *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide 
    883            *                              bus mode.
    884            *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed).
    885            *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received.
    886            *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61.
    887            * @retval None
    888            */
    889          void SDIO_ClearFlag(uint32_t SDIO_FLAG)
    890          { 
    891            /* Check the parameters */
    892            assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
    893             
    894            SDIO->ICR = SDIO_FLAG;
    895          }
    896          
    897          /**
    898            * @brief  Checks whether the specified SDIO interrupt has occurred or not.
    899            * @param  SDIO_IT: specifies the SDIO interrupt source to check. 
    900            *   This parameter can be one of the following values:
    901            *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt.
    902            *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt.
    903            *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt.
    904            *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt.
    905            *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt.
    906            *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt.
    907            *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt.
    908            *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt.
    909            *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt.
    910            *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    911            *                            bus mode interrupt.
    912            *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt.
    913            *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt.
    914            *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt.
    915            *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt.
    916            *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt.
    917            *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt.
    918            *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt.
    919            *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt.
    920            *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt.
    921            *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt.
    922            *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt.
    923            *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt.
    924            *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt.
    925            *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt.
    926            * @retval The new state of SDIO_IT (SET or RESET).
    927            */
    928          ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
    929          { 
    930            ITStatus bitstatus = RESET;
    931            
    932            /* Check the parameters */
    933            assert_param(IS_SDIO_GET_IT(SDIO_IT));
    934            if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
    935            {
    936              bitstatus = SET;
    937            }
    938            else
    939            {
    940              bitstatus = RESET;
    941            }
    942            return bitstatus;
    943          }
    944          
    945          /**
    946            * @brief  Clears the SDIO's interrupt pending bits.
    947            * @param  SDIO_IT: specifies the interrupt pending bit to clear. 
    948            *   This parameter can be one or a combination of the following values:
    949            *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt.
    950            *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt.
    951            *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt.
    952            *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt.
    953            *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt.
    954            *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt.
    955            *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt.
    956            *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt.
    957            *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt.
    958            *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    959            *                            bus mode interrupt.
    960            *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt.
    961            *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61.
    962            * @retval None
    963            */
    964          void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
    965          { 
    966            /* Check the parameters */
    967            assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
    968             
    969            SDIO->ICR = SDIO_IT;
    970          }
    971          
    972          /**
    973            * @}
    974            */
    975          
    976          /**
    977            * @}
    978            */
    979          
    980          /**
    981            * @}
    982            */
    983          
    984          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SDIO_CEATAITCmd
       0   SDIO_ClearFlag
       0   SDIO_ClearITPendingBit
       0   SDIO_ClockCmd
       0   SDIO_CmdStructInit
       0   SDIO_CommandCompletionCmd
       0   SDIO_DMACmd
       0   SDIO_DataConfig
       0   SDIO_DataStructInit
       8   SDIO_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   SDIO_GetCommandResponse
       0   SDIO_GetDataCounter
       0   SDIO_GetFIFOCount
       0   SDIO_GetFlagStatus
       0   SDIO_GetITStatus
       0   SDIO_GetPowerState
       4   SDIO_GetResponse
       0   SDIO_ITConfig
       0   SDIO_Init
       0   SDIO_ReadData
       0   SDIO_SendCEATACmd
       0   SDIO_SendCommand
       0   SDIO_SendSDIOSuspendCmd
       0   SDIO_SetPowerState
       0   SDIO_SetSDIOOperation
       0   SDIO_SetSDIOReadWaitMode
       0   SDIO_StartSDIOReadWait
       0   SDIO_StopSDIOReadWait
       0   SDIO_StructInit
       0   SDIO_WriteData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_17
       4  ??DataTable25_18
       4  ??DataTable25_19
       4  ??DataTable25_2
       4  ??DataTable25_20
       4  ??DataTable25_21
       4  ??DataTable25_22
       4  ??DataTable25_23
       4  ??DataTable25_24
       4  ??DataTable25_25
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
      14  SDIO_CEATAITCmd
       6  SDIO_ClearFlag
       6  SDIO_ClearITPendingBit
       8  SDIO_ClockCmd
      22  SDIO_CmdStructInit
       8  SDIO_CommandCompletionCmd
       8  SDIO_DMACmd
      44  SDIO_DataConfig
      28  SDIO_DataStructInit
      24  SDIO_DeInit
       8  SDIO_GetCommandResponse
       6  SDIO_GetDataCounter
       6  SDIO_GetFIFOCount
      22  SDIO_GetFlagStatus
      22  SDIO_GetITStatus
      10  SDIO_GetPowerState
      20  SDIO_GetResponse
      32  SDIO_ITConfig
      40  SDIO_Init
       6  SDIO_ReadData
       8  SDIO_SendCEATACmd
      38  SDIO_SendCommand
       8  SDIO_SendSDIOSuspendCmd
       6  SDIO_SetPowerState
       8  SDIO_SetSDIOOperation
       6  SDIO_SetSDIOReadWaitMode
       8  SDIO_StartSDIOReadWait
       8  SDIO_StopSDIOReadWait
      26  SDIO_StructInit
       6  SDIO_WriteData

 
 566 bytes in section .text
 
 566 bytes of CODE memory

Errors: none
Warnings: none
